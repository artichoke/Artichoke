<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/work/artichoke/artichoke/target/debug/build/artichoke-backend-4ea485c4ba485d28/out/ffi.rs`."><title>ffi.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../../../../../../../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../../../../../../../../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../../../../../../../../../../static.files/rustdoc-cf3c48c1.css"><meta name="rustdoc-vars" data-root-path="../../../../../../../../../../../../" data-static-root-path="../../../../../../../../../../../../static.files/" data-current-crate="artichoke_backend" data-themes="" data-resource-suffix="" data-rustdoc-version="1.86.0-nightly (124cc9219 2025-02-09)" data-channel="nightly" data-search-js="search-581efc7a.js" data-settings-js="settings-6dad6058.js" ><script src="../../../../../../../../../../../../static.files/storage-3a5871a4.js"></script><script defer src="../../../../../../../../../../../../static.files/src-script-8fee9dc5.js"></script><script defer src="../../../../../../../../../../../../src-files.js"></script><script defer src="../../../../../../../../../../../../static.files/main-4d63596a.js"></script><noscript><link rel="stylesheet" href="../../../../../../../../../../../../static.files/noscript-893ab5e7.css"></noscript><link rel="icon" href="https://www.artichokeruby.org/favicon-32x32.png"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1><div class="sub-heading">artichoke_backend/home/runner/work/artichoke/artichoke/target/debug/build/artichoke-backend-4ea485c4ba485d28/out/</div>ffi.rs</h1><rustdoc-toolbar></rustdoc-toolbar></div><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers">
<a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a></pre></div><pre class="rust"><code><span class="comment">/* automatically generated by rust-bindgen 0.71.1 */

</span># [repr (C)] # [derive (Copy , Clone , Debug , Default , Eq , Hash , Ord , PartialEq , PartialOrd)] <span class="kw">pub struct </span>__BindgenBitfieldUnit &lt; Storage &gt; { storage : Storage , } <span class="kw">impl </span>&lt; Storage &gt; __BindgenBitfieldUnit &lt; Storage &gt; { # [inline] <span class="kw">pub const fn </span>new (storage : Storage) -&gt; <span class="self">Self </span>{ <span class="self">Self </span>{ storage } } } <span class="kw">impl </span>&lt; Storage &gt; __BindgenBitfieldUnit &lt; Storage &gt; <span class="kw">where </span>Storage : AsRef &lt; [u8] &gt; + AsMut &lt; [u8] &gt;, { # [inline] <span class="kw">fn </span>extract_bit (byte : u8 , index : usize) -&gt; bool { <span class="kw">let </span>bit_index = <span class="kw">if </span>cfg ! (target_endian = <span class="string">"big"</span>) { <span class="number">7 </span>- (index % <span class="number">8</span>) } <span class="kw">else </span>{ index % <span class="number">8 </span>} ; <span class="kw">let </span>mask = <span class="number">1 </span>&lt;&lt; bit_index ; byte &amp; mask == mask } # [inline] <span class="kw">pub fn </span>get_bit (&amp; <span class="self">self </span>, index : usize) -&gt; bool { debug_assert ! (index / <span class="number">8 </span>&lt; <span class="self">self </span>. storage . as_ref () . len ()) ; <span class="kw">let </span>byte_index = index / <span class="number">8 </span>; <span class="kw">let </span>byte = <span class="self">self </span>. storage . as_ref () [byte_index] ; <span class="self">Self </span>:: extract_bit (byte , index) } # [inline] <span class="kw">pub unsafe fn </span>raw_get_bit (this : * <span class="kw">const </span><span class="self">Self </span>, index : usize) -&gt; bool { debug_assert ! (index / <span class="number">8 </span>&lt; core :: mem :: size_of ::&lt; Storage &gt; ()) ; <span class="kw">let </span>byte_index = index / <span class="number">8 </span>; <span class="kw">let </span>byte = * (core :: ptr :: addr_of ! ((* this) . storage) <span class="kw">as </span>* <span class="kw">const </span>u8) . offset (byte_index <span class="kw">as </span>isize) ; <span class="self">Self </span>:: extract_bit (byte , index) } # [inline] <span class="kw">fn </span>change_bit (byte : u8 , index : usize , val : bool) -&gt; u8 { <span class="kw">let </span>bit_index = <span class="kw">if </span>cfg ! (target_endian = <span class="string">"big"</span>) { <span class="number">7 </span>- (index % <span class="number">8</span>) } <span class="kw">else </span>{ index % <span class="number">8 </span>} ; <span class="kw">let </span>mask = <span class="number">1 </span>&lt;&lt; bit_index ; <span class="kw">if </span>val { byte | mask } <span class="kw">else </span>{ byte &amp; ! mask } } # [inline] <span class="kw">pub fn </span>set_bit (&amp; <span class="kw-2">mut </span><span class="self">self </span>, index : usize , val : bool) { debug_assert ! (index / <span class="number">8 </span>&lt; <span class="self">self </span>. storage . as_ref () . len ()) ; <span class="kw">let </span>byte_index = index / <span class="number">8 </span>; <span class="kw">let </span>byte = &amp; <span class="kw-2">mut </span><span class="self">self </span>. storage . as_mut () [byte_index] ; * byte = <span class="self">Self </span>:: change_bit (* byte , index , val) ; } # [inline] <span class="kw">pub unsafe fn </span>raw_set_bit (this : * <span class="kw-2">mut </span><span class="self">Self </span>, index : usize , val : bool) { debug_assert ! (index / <span class="number">8 </span>&lt; core :: mem :: size_of ::&lt; Storage &gt; ()) ; <span class="kw">let </span>byte_index = index / <span class="number">8 </span>; <span class="kw">let </span>byte = (core :: ptr :: addr_of_mut ! ((* this) . storage) <span class="kw">as </span>* <span class="kw-2">mut </span>u8) . offset (byte_index <span class="kw">as </span>isize) ; * byte = <span class="self">Self </span>:: change_bit (* byte , index , val) ; } # [inline] <span class="kw">pub fn </span>get (&amp; <span class="self">self </span>, bit_offset : usize , bit_width : u8) -&gt; u64 { debug_assert ! (bit_width &lt;= <span class="number">64</span>) ; debug_assert ! (bit_offset / <span class="number">8 </span>&lt; <span class="self">self </span>. storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width <span class="kw">as </span>usize)) / <span class="number">8 </span>&lt;= <span class="self">self </span>. storage . as_ref () . len ()) ; <span class="kw">let </span><span class="kw-2">mut </span>val = <span class="number">0 </span>; <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. (bit_width <span class="kw">as </span>usize) { <span class="kw">if </span><span class="self">self </span>. get_bit (i + bit_offset) { <span class="kw">let </span>index = <span class="kw">if </span>cfg ! (target_endian = <span class="string">"big"</span>) { bit_width <span class="kw">as </span>usize - <span class="number">1 </span>- i } <span class="kw">else </span>{ i } ; val |= <span class="number">1 </span>&lt;&lt; index ; } } val } # [inline] <span class="kw">pub unsafe fn </span>raw_get (this : * <span class="kw">const </span><span class="self">Self </span>, bit_offset : usize , bit_width : u8 ,) -&gt; u64 { debug_assert ! (bit_width &lt;= <span class="number">64</span>) ; debug_assert ! (bit_offset / <span class="number">8 </span>&lt; core :: mem :: size_of ::&lt; Storage &gt; ()) ; debug_assert ! ((bit_offset + (bit_width <span class="kw">as </span>usize)) / <span class="number">8 </span>&lt;= core :: mem :: size_of ::&lt; Storage &gt; ()) ; <span class="kw">let </span><span class="kw-2">mut </span>val = <span class="number">0 </span>; <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. (bit_width <span class="kw">as </span>usize) { <span class="kw">if </span><span class="self">Self </span>:: raw_get_bit (this , i + bit_offset) { <span class="kw">let </span>index = <span class="kw">if </span>cfg ! (target_endian = <span class="string">"big"</span>) { bit_width <span class="kw">as </span>usize - <span class="number">1 </span>- i } <span class="kw">else </span>{ i } ; val |= <span class="number">1 </span>&lt;&lt; index ; } } val } # [inline] <span class="kw">pub fn </span>set (&amp; <span class="kw-2">mut </span><span class="self">self </span>, bit_offset : usize , bit_width : u8 , val : u64) { debug_assert ! (bit_width &lt;= <span class="number">64</span>) ; debug_assert ! (bit_offset / <span class="number">8 </span>&lt; <span class="self">self </span>. storage . as_ref () . len ()) ; debug_assert ! ((bit_offset + (bit_width <span class="kw">as </span>usize)) / <span class="number">8 </span>&lt;= <span class="self">self </span>. storage . as_ref () . len ()) ; <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. (bit_width <span class="kw">as </span>usize) { <span class="kw">let </span>mask = <span class="number">1 </span>&lt;&lt; i ; <span class="kw">let </span>val_bit_is_set = val &amp; mask == mask ; <span class="kw">let </span>index = <span class="kw">if </span>cfg ! (target_endian = <span class="string">"big"</span>) { bit_width <span class="kw">as </span>usize - <span class="number">1 </span>- i } <span class="kw">else </span>{ i } ; <span class="self">self </span>. set_bit (index + bit_offset , val_bit_is_set) ; } } # [inline] <span class="kw">pub unsafe fn </span>raw_set (this : * <span class="kw-2">mut </span><span class="self">Self </span>, bit_offset : usize , bit_width : u8 , val : u64 ,) { debug_assert ! (bit_width &lt;= <span class="number">64</span>) ; debug_assert ! (bit_offset / <span class="number">8 </span>&lt; core :: mem :: size_of ::&lt; Storage &gt; ()) ; debug_assert ! ((bit_offset + (bit_width <span class="kw">as </span>usize)) / <span class="number">8 </span>&lt;= core :: mem :: size_of ::&lt; Storage &gt; ()) ; <span class="kw">for </span>i <span class="kw">in </span><span class="number">0 </span>.. (bit_width <span class="kw">as </span>usize) { <span class="kw">let </span>mask = <span class="number">1 </span>&lt;&lt; i ; <span class="kw">let </span>val_bit_is_set = val &amp; mask == mask ; <span class="kw">let </span>index = <span class="kw">if </span>cfg ! (target_endian = <span class="string">"big"</span>) { bit_width <span class="kw">as </span>usize - <span class="number">1 </span>- i } <span class="kw">else </span>{ i } ; <span class="self">Self </span>:: raw_set_bit (this , index + bit_offset , val_bit_is_set) ; } } } <span class="kw">pub const </span>MRB_INT_BIT : u32 = <span class="number">64 </span>; <span class="kw">pub const </span>MRB_PRIo : &amp; [u8 ; <span class="number">3</span>] = <span class="string">b"lo\0" </span>; <span class="kw">pub const </span>MRB_PRId : &amp; [u8 ; <span class="number">3</span>] = <span class="string">b"ld\0" </span>; <span class="kw">pub const </span>MRB_PRIx : &amp; [u8 ; <span class="number">3</span>] = <span class="string">b"lx\0" </span>; <span class="kw">pub const </span>MRB_FL_OBJ_IS_FROZEN : u32 = <span class="number">1048576 </span>; <span class="kw">pub const </span>MRB_FIXNUM_SHIFT : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRB_SYMBOL_SHIFT : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRB_EACH_OBJ_OK : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRB_EACH_OBJ_BREAK : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>MRB_GC_ARENA_SIZE : u32 = <span class="number">100 </span>; <span class="kw">pub const </span>MRB_GC_RED : u32 = <span class="number">7 </span>; <span class="kw">pub const </span>MRUBY_RUBY_VERSION : &amp; [u8 ; <span class="number">4</span>] = <span class="string">b"3.2\0" </span>; <span class="kw">pub const </span>MRUBY_RUBY_ENGINE : &amp; [u8 ; <span class="number">6</span>] = <span class="string">b"mruby\0" </span>; <span class="kw">pub const </span>MRUBY_RELEASE_MAJOR : u32 = <span class="number">3 </span>; <span class="kw">pub const </span>MRUBY_RELEASE_MINOR : u32 = <span class="number">2 </span>; <span class="kw">pub const </span>MRUBY_RELEASE_TEENY : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRUBY_PATCHLEVEL : i32 = - <span class="number">1 </span>; <span class="kw">pub const </span>MRUBY_PATCHLEVEL_STR : &amp; [u8 ; <span class="number">1</span>] = <span class="string">b"\0" </span>; <span class="kw">pub const </span>MRUBY_RELEASE_NO : u32 = <span class="number">30200 </span>; <span class="kw">pub const </span>MRUBY_RELEASE_YEAR : u32 = <span class="number">2023 </span>; <span class="kw">pub const </span>MRUBY_RELEASE_MONTH : u32 = <span class="number">2 </span>; <span class="kw">pub const </span>MRUBY_RELEASE_DAY : u32 = <span class="number">24 </span>; <span class="kw">pub const </span>MRUBY_BIRTH_YEAR : u32 = <span class="number">2010 </span>; <span class="kw">pub const </span>MRUBY_AUTHOR : &amp; [u8 ; <span class="number">17</span>] = <span class="string">b"mruby developers\0" </span>; <span class="kw">pub const </span>MRB_FIXED_STATE_ATEXIT_STACK_SIZE : u32 = <span class="number">5 </span>; <span class="kw">pub const </span>MRB_METHOD_CACHE_SIZE : u32 = <span class="number">256 </span>; <span class="kw">pub const </span>MRB_ARY_EMBED_LEN_MAX : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRB_ARY_SHARED : u32 = <span class="number">256 </span>; <span class="kw">pub const </span>MRB_FL_CLASS_IS_PREPENDED : u32 = <span class="number">524288 </span>; <span class="kw">pub const </span>MRB_FL_CLASS_IS_ORIGIN : u32 = <span class="number">262144 </span>; <span class="kw">pub const </span>MRB_FL_CLASS_IS_INHERITED : u32 = <span class="number">131072 </span>; <span class="kw">pub const </span>MRB_INSTANCE_TT_MASK : u32 = <span class="number">255 </span>; <span class="kw">pub const </span>MRB_PARSER_TOKBUF_MAX : u32 = <span class="number">65534 </span>; <span class="kw">pub const </span>MRB_PARSER_TOKBUF_SIZE : u32 = <span class="number">256 </span>; <span class="kw">pub const </span>MRB_ISEQ_NO_FREE : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>MRB_IREP_NO_FREE : u32 = <span class="number">2 </span>; <span class="kw">pub const </span>MRB_IREP_STATIC : u32 = <span class="number">3 </span>; <span class="kw">pub const </span>MRB_DUMP_DEBUG_INFO : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>MRB_DUMP_STATIC : u32 = <span class="number">2 </span>; <span class="kw">pub const </span>MRB_DUMP_OK : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRB_DUMP_GENERAL_FAILURE : i32 = - <span class="number">1 </span>; <span class="kw">pub const </span>MRB_DUMP_WRITE_FAULT : i32 = - <span class="number">2 </span>; <span class="kw">pub const </span>MRB_DUMP_READ_FAULT : i32 = - <span class="number">3 </span>; <span class="kw">pub const </span>MRB_DUMP_INVALID_FILE_HEADER : i32 = - <span class="number">4 </span>; <span class="kw">pub const </span>MRB_DUMP_INVALID_IREP : i32 = - <span class="number">5 </span>; <span class="kw">pub const </span>MRB_DUMP_INVALID_ARGUMENT : i32 = - <span class="number">6 </span>; <span class="kw">pub const </span>MRB_DUMP_NULL_SYM_LEN : u32 = <span class="number">65535 </span>; <span class="kw">pub const </span>MRB_DUMP_DEFAULT_STR_LEN : u32 = <span class="number">128 </span>; <span class="kw">pub const </span>MRB_EXC_EXIT : u32 = <span class="number">65536 </span>; <span class="kw">pub const </span>MRB_HASH_IB_BIT_BIT : u32 = <span class="number">5 </span>; <span class="kw">pub const </span>MRB_HASH_AR_EA_CAPA_BIT : u32 = <span class="number">5 </span>; <span class="kw">pub const </span>MRB_HASH_IB_BIT_SHIFT : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRB_HASH_AR_EA_CAPA_SHIFT : u32 = <span class="number">0 </span>; <span class="kw">pub const </span>MRB_HASH_AR_EA_N_USED_SHIFT : u32 = <span class="number">5 </span>; <span class="kw">pub const </span>MRB_HASH_SIZE_FLAGS_SHIFT : u32 = <span class="number">10 </span>; <span class="kw">pub const </span>MRB_HASH_IB_BIT_MASK : u32 = <span class="number">31 </span>; <span class="kw">pub const </span>MRB_HASH_AR_EA_CAPA_MASK : u32 = <span class="number">31 </span>; <span class="kw">pub const </span>MRB_HASH_AR_EA_N_USED_MASK : u32 = <span class="number">992 </span>; <span class="kw">pub const </span>MRB_HASH_DEFAULT : u32 = <span class="number">1024 </span>; <span class="kw">pub const </span>MRB_HASH_PROC_DEFAULT : u32 = <span class="number">2048 </span>; <span class="kw">pub const </span>MRB_HASH_HT : u32 = <span class="number">4096 </span>; <span class="kw">pub const </span>MRB_ENV_CLOSED : u32 = <span class="number">1048576 </span>; <span class="kw">pub const </span>MRB_PROC_CFUNC_FL : u32 = <span class="number">128 </span>; <span class="kw">pub const </span>MRB_PROC_STRICT : u32 = <span class="number">256 </span>; <span class="kw">pub const </span>MRB_PROC_ORPHAN : u32 = <span class="number">512 </span>; <span class="kw">pub const </span>MRB_PROC_ENVSET : u32 = <span class="number">1024 </span>; <span class="kw">pub const </span>MRB_PROC_SCOPE : u32 = <span class="number">2048 </span>; <span class="kw">pub const </span>MRB_PROC_NOARG : u32 = <span class="number">4096 </span>; <span class="kw">pub const </span>MRB_METHOD_FUNC_FL : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>MRB_METHOD_NOARG_FL : u32 = <span class="number">2 </span>; <span class="kw">pub const </span>MRB_STR_SHARED : u32 = <span class="number">1 </span>; <span class="kw">pub const </span>MRB_STR_FSHARED : u32 = <span class="number">2 </span>; <span class="kw">pub const </span>MRB_STR_NOFREE : u32 = <span class="number">4 </span>; <span class="kw">pub const </span>MRB_STR_EMBED : u32 = <span class="number">8 </span>; <span class="kw">pub const </span>MRB_STR_ASCII : u32 = <span class="number">16 </span>; <span class="kw">pub const </span>MRB_STR_EMBED_LEN_SHIFT : u32 = <span class="number">6 </span>; <span class="kw">pub const </span>MRB_STR_EMBED_LEN_BIT : u32 = <span class="number">5 </span>; <span class="kw">pub const </span>MRB_STR_EMBED_LEN_MASK : u32 = <span class="number">1984 </span>; <span class="kw">pub const </span>MRB_STR_TYPE_MASK : u32 = <span class="number">15 </span>; <span class="kw">pub type </span>va_list = __builtin_va_list ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>__sigset_t { <span class="kw">pub </span>__val : [:: std :: os :: raw :: c_ulong ; <span class="number">16usize</span>] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of __sigset_t"</span>] [:: std :: mem :: size_of :: &lt; __sigset_t &gt; () - <span class="number">128usize</span>] ; [<span class="string">"Alignment of __sigset_t"</span>] [:: std :: mem :: align_of :: &lt; __sigset_t &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: __sigset_t::__val"</span>] [:: std :: mem :: offset_of ! (__sigset_t , __val) - <span class="number">0usize</span>] ; } ; <span class="kw">pub type </span>mrb_sym = u32 ; <span class="kw">pub type </span>mrb_bool = bool ; <span class="kw">pub type </span>mrb_int = i64 ; <span class="kw">pub type </span>mrb_uint = u64 ; <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_read_int (p : * <span class="kw">const </span>:: std :: os :: raw :: c_char , e : * <span class="kw">const </span>:: std :: os :: raw :: c_char , endp : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , np : * <span class="kw-2">mut </span>mrb_int) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_int_read (arg1 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg3 : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>:: std :: os :: raw :: c_char) -&gt; mrb_int ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_read_float (p : * <span class="kw">const </span>:: std :: os :: raw :: c_char , endp : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , fp : * <span class="kw-2">mut </span>f64) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_float_read (p : * <span class="kw">const </span>:: std :: os :: raw :: c_char , endp : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>:: std :: os :: raw :: c_char) -&gt; f64 ; } <span class="kw">pub type </span>mrb_float = f64 ; # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_vtype { MRB_TT_FALSE = <span class="number">0 </span>, MRB_TT_TRUE = <span class="number">1 </span>, MRB_TT_SYMBOL = <span class="number">2 </span>, MRB_TT_UNDEF = <span class="number">3 </span>, MRB_TT_FREE = <span class="number">4 </span>, MRB_TT_FLOAT = <span class="number">5 </span>, MRB_TT_INTEGER = <span class="number">6 </span>, MRB_TT_CPTR = <span class="number">7 </span>, MRB_TT_OBJECT = <span class="number">8 </span>, MRB_TT_CLASS = <span class="number">9 </span>, MRB_TT_MODULE = <span class="number">10 </span>, MRB_TT_ICLASS = <span class="number">11 </span>, MRB_TT_SCLASS = <span class="number">12 </span>, MRB_TT_PROC = <span class="number">13 </span>, MRB_TT_ARRAY = <span class="number">14 </span>, MRB_TT_HASH = <span class="number">15 </span>, MRB_TT_STRING = <span class="number">16 </span>, MRB_TT_RANGE = <span class="number">17 </span>, MRB_TT_EXCEPTION = <span class="number">18 </span>, MRB_TT_ENV = <span class="number">19 </span>, MRB_TT_CDATA = <span class="number">20 </span>, MRB_TT_FIBER = <span class="number">21 </span>, MRB_TT_STRUCT = <span class="number">22 </span>, MRB_TT_ISTRUCT = <span class="number">23 </span>, MRB_TT_BREAK = <span class="number">24 </span>, MRB_TT_COMPLEX = <span class="number">25 </span>, MRB_TT_RATIONAL = <span class="number">26 </span>, MRB_TT_BIGINT = <span class="number">27 </span>, MRB_TT_MAXDEFINE = <span class="number">28 </span>, } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>RBasic { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>__bindgen_padding_0 : u32 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RBasic"</span>] [:: std :: mem :: size_of :: &lt; RBasic &gt; () - <span class="number">24usize</span>] ; [<span class="string">"Alignment of RBasic"</span>] [:: std :: mem :: align_of :: &lt; RBasic &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RBasic::c"</span>] [:: std :: mem :: offset_of ! (RBasic , c) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RBasic::gcnext"</span>] [:: std :: mem :: offset_of ! (RBasic , gcnext) - <span class="number">8usize</span>] ; } ; <span class="kw">impl </span>RBasic { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>tt_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_tt_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>color_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_color_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>flags_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_flags_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>RObject { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>iv : * <span class="kw-2">mut </span>iv_tbl , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RObject"</span>] [:: std :: mem :: size_of :: &lt; RObject &gt; () - <span class="number">32usize</span>] ; [<span class="string">"Alignment of RObject"</span>] [:: std :: mem :: align_of :: &lt; RObject &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RObject::c"</span>] [:: std :: mem :: offset_of ! (RObject , c) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RObject::gcnext"</span>] [:: std :: mem :: offset_of ! (RObject , gcnext) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RObject::iv"</span>] [:: std :: mem :: offset_of ! (RObject , iv) - <span class="number">24usize</span>] ; } ; <span class="kw">impl </span>RObject { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>tt_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_tt_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>color_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_color_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>flags_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_flags_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>RFiber { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>cxt : * <span class="kw-2">mut </span>mrb_context , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RFiber"</span>] [:: std :: mem :: size_of :: &lt; RFiber &gt; () - <span class="number">32usize</span>] ; [<span class="string">"Alignment of RFiber"</span>] [:: std :: mem :: align_of :: &lt; RFiber &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RFiber::c"</span>] [:: std :: mem :: offset_of ! (RFiber , c) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RFiber::gcnext"</span>] [:: std :: mem :: offset_of ! (RFiber , gcnext) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RFiber::cxt"</span>] [:: std :: mem :: offset_of ! (RFiber , cxt) - <span class="number">24usize</span>] ; } ; <span class="kw">impl </span>RFiber { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>tt_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_tt_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>color_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_color_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>flags_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_flags_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>mrb_value_union { <span class="kw">pub </span>f : mrb_float , <span class="kw">pub </span>p : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , <span class="kw">pub </span>i : mrb_int , <span class="kw">pub </span>sym : mrb_sym , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_value_union"</span>] [:: std :: mem :: size_of :: &lt; mrb_value_union &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Alignment of mrb_value_union"</span>] [:: std :: mem :: align_of :: &lt; mrb_value_union &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_value_union::f"</span>] [:: std :: mem :: offset_of ! (mrb_value_union , f) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_value_union::p"</span>] [:: std :: mem :: offset_of ! (mrb_value_union , p) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_value_union::i"</span>] [:: std :: mem :: offset_of ! (mrb_value_union , i) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_value_union::sym"</span>] [:: std :: mem :: offset_of ! (mrb_value_union , sym) - <span class="number">0usize</span>] ; } ; # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>mrb_value { <span class="kw">pub </span>value : mrb_value_union , <span class="kw">pub </span>tt : mrb_vtype , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_value"</span>] [:: std :: mem :: size_of :: &lt; mrb_value &gt; () - <span class="number">16usize</span>] ; [<span class="string">"Alignment of mrb_value"</span>] [:: std :: mem :: align_of :: &lt; mrb_value &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_value::value"</span>] [:: std :: mem :: offset_of ! (mrb_value , value) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_value::tt"</span>] [:: std :: mem :: offset_of ! (mrb_value , tt) - <span class="number">8usize</span>] ; } ; <span class="kw">pub type </span>mrb_ssize = mrb_int ; <span class="kw">pub type </span>mrb_each_object_callback = :: std :: option :: <span class="prelude-ty">Option</span> &lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(mrb : * <span class="kw-2">mut </span>mrb_state , obj : * <span class="kw-2">mut </span>RBasic , data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; :: std :: os :: raw :: c_int &gt; ; <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_objspace_each_objects (mrb : * <span class="kw-2">mut </span>mrb_state , callback : mrb_each_object_callback , data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_objspace_page_slot_size () -&gt; usize ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_free_context (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>mrb_context) ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_gc_state { MRB_GC_STATE_ROOT = <span class="number">0 </span>, MRB_GC_STATE_MARK = <span class="number">1 </span>, MRB_GC_STATE_SWEEP = <span class="number">2 </span>, } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_heap_page { <span class="kw">pub </span>freelist : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>prev : * <span class="kw-2">mut </span>mrb_heap_page , <span class="kw">pub </span>next : * <span class="kw-2">mut </span>mrb_heap_page , <span class="kw">pub </span>free_next : * <span class="kw-2">mut </span>mrb_heap_page , <span class="kw">pub </span>free_prev : * <span class="kw-2">mut </span>mrb_heap_page , <span class="kw">pub </span>_bitfield_align_1 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>__bindgen_padding_0 : [u8 ; <span class="number">7usize</span>] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_heap_page"</span>] [:: std :: mem :: size_of :: &lt; mrb_heap_page &gt; () - <span class="number">48usize</span>] ; [<span class="string">"Alignment of mrb_heap_page"</span>] [:: std :: mem :: align_of :: &lt; mrb_heap_page &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_heap_page::freelist"</span>] [:: std :: mem :: offset_of ! (mrb_heap_page , freelist) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_heap_page::prev"</span>] [:: std :: mem :: offset_of ! (mrb_heap_page , prev) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_heap_page::next"</span>] [:: std :: mem :: offset_of ! (mrb_heap_page , next) - <span class="number">16usize</span>] ; [<span class="string">"Offset of field: mrb_heap_page::free_next"</span>] [:: std :: mem :: offset_of ! (mrb_heap_page , free_next) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: mrb_heap_page::free_prev"</span>] [:: std :: mem :: offset_of ! (mrb_heap_page , free_prev) - <span class="number">32usize</span>] ; } ; <span class="kw">impl </span>mrb_heap_page { # [inline] <span class="kw">pub fn </span>old (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_old (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>old_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_old_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (old : mrb_bool) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>old : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (old) } ; old <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_gc { <span class="kw">pub </span>heaps : * <span class="kw-2">mut </span>mrb_heap_page , <span class="kw">pub </span>sweeps : * <span class="kw-2">mut </span>mrb_heap_page , <span class="kw">pub </span>free_heaps : * <span class="kw-2">mut </span>mrb_heap_page , <span class="kw">pub </span>live : usize , <span class="kw">pub </span>arena : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>arena_capa : :: std :: os :: raw :: c_int , <span class="kw">pub </span>arena_idx : :: std :: os :: raw :: c_int , <span class="kw">pub </span>state : mrb_gc_state , <span class="kw">pub </span>current_white_part : :: std :: os :: raw :: c_int , <span class="kw">pub </span>gray_list : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>atomic_gray_list : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>live_after_mark : usize , <span class="kw">pub </span>threshold : usize , <span class="kw">pub </span>interval_ratio : :: std :: os :: raw :: c_int , <span class="kw">pub </span>step_ratio : :: std :: os :: raw :: c_int , <span class="kw">pub </span>_bitfield_align_1 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>majorgc_old_threshold : usize , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_gc"</span>] [:: std :: mem :: size_of :: &lt; mrb_gc &gt; () - <span class="number">112usize</span>] ; [<span class="string">"Alignment of mrb_gc"</span>] [:: std :: mem :: align_of :: &lt; mrb_gc &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_gc::heaps"</span>] [:: std :: mem :: offset_of ! (mrb_gc , heaps) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_gc::sweeps"</span>] [:: std :: mem :: offset_of ! (mrb_gc , sweeps) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_gc::free_heaps"</span>] [:: std :: mem :: offset_of ! (mrb_gc , free_heaps) - <span class="number">16usize</span>] ; [<span class="string">"Offset of field: mrb_gc::live"</span>] [:: std :: mem :: offset_of ! (mrb_gc , live) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: mrb_gc::arena"</span>] [:: std :: mem :: offset_of ! (mrb_gc , arena) - <span class="number">32usize</span>] ; [<span class="string">"Offset of field: mrb_gc::arena_capa"</span>] [:: std :: mem :: offset_of ! (mrb_gc , arena_capa) - <span class="number">40usize</span>] ; [<span class="string">"Offset of field: mrb_gc::arena_idx"</span>] [:: std :: mem :: offset_of ! (mrb_gc , arena_idx) - <span class="number">44usize</span>] ; [<span class="string">"Offset of field: mrb_gc::state"</span>] [:: std :: mem :: offset_of ! (mrb_gc , state) - <span class="number">48usize</span>] ; [<span class="string">"Offset of field: mrb_gc::current_white_part"</span>] [:: std :: mem :: offset_of ! (mrb_gc , current_white_part) - <span class="number">52usize</span>] ; [<span class="string">"Offset of field: mrb_gc::gray_list"</span>] [:: std :: mem :: offset_of ! (mrb_gc , gray_list) - <span class="number">56usize</span>] ; [<span class="string">"Offset of field: mrb_gc::atomic_gray_list"</span>] [:: std :: mem :: offset_of ! (mrb_gc , atomic_gray_list) - <span class="number">64usize</span>] ; [<span class="string">"Offset of field: mrb_gc::live_after_mark"</span>] [:: std :: mem :: offset_of ! (mrb_gc , live_after_mark) - <span class="number">72usize</span>] ; [<span class="string">"Offset of field: mrb_gc::threshold"</span>] [:: std :: mem :: offset_of ! (mrb_gc , threshold) - <span class="number">80usize</span>] ; [<span class="string">"Offset of field: mrb_gc::interval_ratio"</span>] [:: std :: mem :: offset_of ! (mrb_gc , interval_ratio) - <span class="number">88usize</span>] ; [<span class="string">"Offset of field: mrb_gc::step_ratio"</span>] [:: std :: mem :: offset_of ! (mrb_gc , step_ratio) - <span class="number">92usize</span>] ; [<span class="string">"Offset of field: mrb_gc::majorgc_old_threshold"</span>] [:: std :: mem :: offset_of ! (mrb_gc , majorgc_old_threshold) - <span class="number">104usize</span>] ; } ; <span class="kw">impl </span>mrb_gc { # [inline] <span class="kw">pub fn </span>iterating (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_iterating (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>iterating_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_iterating_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>disabled (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">1usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_disabled (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>disabled_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">1usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_disabled_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">1usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>full (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">2usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_full (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>full_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">2usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_full_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">2usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>generational (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">3usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_generational (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">3usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>generational_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">3usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_generational_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">3usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>out_of_memory (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">4usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_out_of_memory (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">4usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>out_of_memory_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">4usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_out_of_memory_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">4usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (iterating : mrb_bool , disabled : mrb_bool , full : mrb_bool , generational : mrb_bool , out_of_memory : mrb_bool) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>iterating : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (iterating) } ; iterating <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>disabled : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (disabled) } ; disabled <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>full : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (full) } ; full <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">3usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>generational : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (generational) } ; generational <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">4usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>out_of_memory : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (out_of_memory) } ; out_of_memory <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_object_dead_p (mrb : * <span class="kw-2">mut </span>mrb_state , object : * <span class="kw-2">mut </span>RBasic) -&gt; mrb_bool ; } <span class="kw">pub type </span>mrb_code = u8 ; <span class="kw">pub type </span>mrb_aspec = u32 ; <span class="kw">pub type </span>mrb_allocf = :: std :: option :: <span class="prelude-ty">Option</span> &lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(mrb : * <span class="kw-2">mut </span>mrb_state , arg1 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , arg2 : usize , ud : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void &gt; ; # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>mrb_callinfo { <span class="kw">pub </span>_bitfield_align_1 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>cci : u8 , <span class="kw">pub </span>mid : mrb_sym , <span class="kw">pub </span>proc_ : * <span class="kw">const </span>RProc , <span class="kw">pub </span>blk : * <span class="kw-2">mut </span>RProc , <span class="kw">pub </span>stack : * <span class="kw-2">mut </span>mrb_value , <span class="kw">pub </span>pc : * <span class="kw">const </span>mrb_code , <span class="kw">pub </span>u : mrb_callinfo__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>mrb_callinfo__bindgen_ty_1 { <span class="kw">pub </span>env : * <span class="kw-2">mut </span>REnv , <span class="kw">pub </span>target_class : * <span class="kw-2">mut </span>RClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_callinfo__bindgen_ty_1"</span>] [:: std :: mem :: size_of :: &lt; mrb_callinfo__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Alignment of mrb_callinfo__bindgen_ty_1"</span>] [:: std :: mem :: align_of :: &lt; mrb_callinfo__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_callinfo__bindgen_ty_1::env"</span>] [:: std :: mem :: offset_of ! (mrb_callinfo__bindgen_ty_1 , env) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_callinfo__bindgen_ty_1::target_class"</span>] [:: std :: mem :: offset_of ! (mrb_callinfo__bindgen_ty_1 , target_class) - <span class="number">0usize</span>] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_callinfo"</span>] [:: std :: mem :: size_of :: &lt; mrb_callinfo &gt; () - <span class="number">48usize</span>] ; [<span class="string">"Alignment of mrb_callinfo"</span>] [:: std :: mem :: align_of :: &lt; mrb_callinfo &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_callinfo::cci"</span>] [:: std :: mem :: offset_of ! (mrb_callinfo , cci) - <span class="number">1usize</span>] ; [<span class="string">"Offset of field: mrb_callinfo::mid"</span>] [:: std :: mem :: offset_of ! (mrb_callinfo , mid) - <span class="number">4usize</span>] ; [<span class="string">"Offset of field: mrb_callinfo::proc_"</span>] [:: std :: mem :: offset_of ! (mrb_callinfo , proc_) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_callinfo::blk"</span>] [:: std :: mem :: offset_of ! (mrb_callinfo , blk) - <span class="number">16usize</span>] ; [<span class="string">"Offset of field: mrb_callinfo::stack"</span>] [:: std :: mem :: offset_of ! (mrb_callinfo , stack) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: mrb_callinfo::pc"</span>] [:: std :: mem :: offset_of ! (mrb_callinfo , pc) - <span class="number">32usize</span>] ; [<span class="string">"Offset of field: mrb_callinfo::u"</span>] [:: std :: mem :: offset_of ! (mrb_callinfo , u) - <span class="number">40usize</span>] ; } ; <span class="kw">impl </span>mrb_callinfo { # [inline] <span class="kw">pub fn </span>n (&amp; <span class="self">self</span>) -&gt; u8 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">4u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_n (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u8) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">4u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>n_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u8 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">4u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_n_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u8) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">4u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>nk (&amp; <span class="self">self</span>) -&gt; u8 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">4usize </span>, <span class="number">4u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_nk (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u8) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">4usize </span>, <span class="number">4u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>nk_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u8 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">4usize </span>, <span class="number">4u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_nk_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u8) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">4usize </span>, <span class="number">4u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (n : u8 , nk : u8) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">4u8 </span>, { <span class="kw">let </span>n : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (n) } ; n <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">4usize </span>, <span class="number">4u8 </span>, { <span class="kw">let </span>nk : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (nk) } ; nk <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_fiber_state { MRB_FIBER_CREATED = <span class="number">0 </span>, MRB_FIBER_RUNNING = <span class="number">1 </span>, MRB_FIBER_RESUMED = <span class="number">2 </span>, MRB_FIBER_SUSPENDED = <span class="number">3 </span>, MRB_FIBER_TRANSFERRED = <span class="number">4 </span>, MRB_FIBER_TERMINATED = <span class="number">5 </span>, } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_context { <span class="kw">pub </span>prev : * <span class="kw-2">mut </span>mrb_context , <span class="kw">pub </span>stbase : * <span class="kw-2">mut </span>mrb_value , <span class="kw">pub </span>stend : * <span class="kw-2">mut </span>mrb_value , <span class="kw">pub </span>ci : * <span class="kw-2">mut </span>mrb_callinfo , <span class="kw">pub </span>cibase : * <span class="kw-2">mut </span>mrb_callinfo , <span class="kw">pub </span>ciend : * <span class="kw-2">mut </span>mrb_callinfo , <span class="kw">pub </span>_bitfield_align_1 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>fib : * <span class="kw-2">mut </span>RFiber , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_context"</span>] [:: std :: mem :: size_of :: &lt; mrb_context &gt; () - <span class="number">64usize</span>] ; [<span class="string">"Alignment of mrb_context"</span>] [:: std :: mem :: align_of :: &lt; mrb_context &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_context::prev"</span>] [:: std :: mem :: offset_of ! (mrb_context , prev) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_context::stbase"</span>] [:: std :: mem :: offset_of ! (mrb_context , stbase) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_context::stend"</span>] [:: std :: mem :: offset_of ! (mrb_context , stend) - <span class="number">16usize</span>] ; [<span class="string">"Offset of field: mrb_context::ci"</span>] [:: std :: mem :: offset_of ! (mrb_context , ci) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: mrb_context::cibase"</span>] [:: std :: mem :: offset_of ! (mrb_context , cibase) - <span class="number">32usize</span>] ; [<span class="string">"Offset of field: mrb_context::ciend"</span>] [:: std :: mem :: offset_of ! (mrb_context , ciend) - <span class="number">40usize</span>] ; [<span class="string">"Offset of field: mrb_context::fib"</span>] [:: std :: mem :: offset_of ! (mrb_context , fib) - <span class="number">56usize</span>] ; } ; <span class="kw">impl </span>mrb_context { # [inline] <span class="kw">pub fn </span>status (&amp; <span class="self">self</span>) -&gt; mrb_fiber_state { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">4u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_status (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_fiber_state) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">4u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>status_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_fiber_state { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">4u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_status_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_fiber_state) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">4u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>vmexec (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">4usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_vmexec (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">4usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>vmexec_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">4usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_vmexec_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">4usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (status : mrb_fiber_state , vmexec : mrb_bool) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">4u8 </span>, { <span class="kw">let </span>status : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (status) } ; status <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">4usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>vmexec : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (vmexec) } ; vmexec <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">pub type </span>mrb_func_t = :: std :: option :: <span class="prelude-ty">Option</span> &lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value &gt; ; <span class="kw">pub type </span>mrb_method_t = usize ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_cache_entry { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>c0 : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>mid : mrb_sym , <span class="kw">pub </span>m : mrb_method_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_cache_entry"</span>] [:: std :: mem :: size_of :: &lt; mrb_cache_entry &gt; () - <span class="number">32usize</span>] ; [<span class="string">"Alignment of mrb_cache_entry"</span>] [:: std :: mem :: align_of :: &lt; mrb_cache_entry &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_cache_entry::c"</span>] [:: std :: mem :: offset_of ! (mrb_cache_entry , c) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_cache_entry::c0"</span>] [:: std :: mem :: offset_of ! (mrb_cache_entry , c0) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_cache_entry::mid"</span>] [:: std :: mem :: offset_of ! (mrb_cache_entry , mid) - <span class="number">16usize</span>] ; [<span class="string">"Offset of field: mrb_cache_entry::m"</span>] [:: std :: mem :: offset_of ! (mrb_cache_entry , m) - <span class="number">24usize</span>] ; } ; <span class="kw">pub type </span>mrb_atexit_func = :: std :: option :: <span class="prelude-ty">Option</span> &lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(arg1 : * <span class="kw-2">mut </span>mrb_state) &gt; ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_state { <span class="kw">pub </span>jmp : * <span class="kw-2">mut </span>mrb_jmpbuf , <span class="kw">pub </span>allocf : mrb_allocf , <span class="kw">pub </span>allocf_ud : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , <span class="kw">pub </span>c : * <span class="kw-2">mut </span>mrb_context , <span class="kw">pub </span>root_c : * <span class="kw-2">mut </span>mrb_context , <span class="kw">pub </span>globals : * <span class="kw-2">mut </span>iv_tbl , <span class="kw">pub </span>exc : * <span class="kw-2">mut </span>RObject , <span class="kw">pub </span>top_self : * <span class="kw-2">mut </span>RObject , <span class="kw">pub </span>object_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>class_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>module_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>proc_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>string_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>array_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>hash_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>range_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>float_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>integer_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>true_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>false_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>nil_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>symbol_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>kernel_module : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gc : mrb_gc , <span class="kw">pub </span>cache : [mrb_cache_entry ; <span class="number">256usize</span>] , <span class="kw">pub </span>symidx : mrb_sym , <span class="kw">pub </span>symtbl : * <span class="kw-2">mut </span>* <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>symlink : * <span class="kw-2">mut </span>u8 , <span class="kw">pub </span>symflags : * <span class="kw-2">mut </span>u8 , <span class="kw">pub </span>symhash : [mrb_sym ; <span class="number">256usize</span>] , <span class="kw">pub </span>symcapa : usize , <span class="kw">pub </span>symbuf : [:: std :: os :: raw :: c_char ; <span class="number">8usize</span>] , <span class="kw">pub </span>eException_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>eStandardError_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>nomem_err : * <span class="kw-2">mut </span>RObject , <span class="kw">pub </span>stack_err : * <span class="kw-2">mut </span>RObject , <span class="kw">pub </span>ud : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , <span class="kw">pub </span>atexit_stack : * <span class="kw-2">mut </span>mrb_atexit_func , <span class="kw">pub </span>atexit_stack_len : u16 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_state"</span>] [:: std :: mem :: size_of :: &lt; mrb_state &gt; () - <span class="number">9616usize</span>] ; [<span class="string">"Alignment of mrb_state"</span>] [:: std :: mem :: align_of :: &lt; mrb_state &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_state::jmp"</span>] [:: std :: mem :: offset_of ! (mrb_state , jmp) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_state::allocf"</span>] [:: std :: mem :: offset_of ! (mrb_state , allocf) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_state::allocf_ud"</span>] [:: std :: mem :: offset_of ! (mrb_state , allocf_ud) - <span class="number">16usize</span>] ; [<span class="string">"Offset of field: mrb_state::c"</span>] [:: std :: mem :: offset_of ! (mrb_state , c) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: mrb_state::root_c"</span>] [:: std :: mem :: offset_of ! (mrb_state , root_c) - <span class="number">32usize</span>] ; [<span class="string">"Offset of field: mrb_state::globals"</span>] [:: std :: mem :: offset_of ! (mrb_state , globals) - <span class="number">40usize</span>] ; [<span class="string">"Offset of field: mrb_state::exc"</span>] [:: std :: mem :: offset_of ! (mrb_state , exc) - <span class="number">48usize</span>] ; [<span class="string">"Offset of field: mrb_state::top_self"</span>] [:: std :: mem :: offset_of ! (mrb_state , top_self) - <span class="number">56usize</span>] ; [<span class="string">"Offset of field: mrb_state::object_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , object_class) - <span class="number">64usize</span>] ; [<span class="string">"Offset of field: mrb_state::class_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , class_class) - <span class="number">72usize</span>] ; [<span class="string">"Offset of field: mrb_state::module_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , module_class) - <span class="number">80usize</span>] ; [<span class="string">"Offset of field: mrb_state::proc_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , proc_class) - <span class="number">88usize</span>] ; [<span class="string">"Offset of field: mrb_state::string_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , string_class) - <span class="number">96usize</span>] ; [<span class="string">"Offset of field: mrb_state::array_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , array_class) - <span class="number">104usize</span>] ; [<span class="string">"Offset of field: mrb_state::hash_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , hash_class) - <span class="number">112usize</span>] ; [<span class="string">"Offset of field: mrb_state::range_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , range_class) - <span class="number">120usize</span>] ; [<span class="string">"Offset of field: mrb_state::float_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , float_class) - <span class="number">128usize</span>] ; [<span class="string">"Offset of field: mrb_state::integer_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , integer_class) - <span class="number">136usize</span>] ; [<span class="string">"Offset of field: mrb_state::true_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , true_class) - <span class="number">144usize</span>] ; [<span class="string">"Offset of field: mrb_state::false_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , false_class) - <span class="number">152usize</span>] ; [<span class="string">"Offset of field: mrb_state::nil_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , nil_class) - <span class="number">160usize</span>] ; [<span class="string">"Offset of field: mrb_state::symbol_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , symbol_class) - <span class="number">168usize</span>] ; [<span class="string">"Offset of field: mrb_state::kernel_module"</span>] [:: std :: mem :: offset_of ! (mrb_state , kernel_module) - <span class="number">176usize</span>] ; [<span class="string">"Offset of field: mrb_state::gc"</span>] [:: std :: mem :: offset_of ! (mrb_state , gc) - <span class="number">184usize</span>] ; [<span class="string">"Offset of field: mrb_state::cache"</span>] [:: std :: mem :: offset_of ! (mrb_state , cache) - <span class="number">296usize</span>] ; [<span class="string">"Offset of field: mrb_state::symidx"</span>] [:: std :: mem :: offset_of ! (mrb_state , symidx) - <span class="number">8488usize</span>] ; [<span class="string">"Offset of field: mrb_state::symtbl"</span>] [:: std :: mem :: offset_of ! (mrb_state , symtbl) - <span class="number">8496usize</span>] ; [<span class="string">"Offset of field: mrb_state::symlink"</span>] [:: std :: mem :: offset_of ! (mrb_state , symlink) - <span class="number">8504usize</span>] ; [<span class="string">"Offset of field: mrb_state::symflags"</span>] [:: std :: mem :: offset_of ! (mrb_state , symflags) - <span class="number">8512usize</span>] ; [<span class="string">"Offset of field: mrb_state::symhash"</span>] [:: std :: mem :: offset_of ! (mrb_state , symhash) - <span class="number">8520usize</span>] ; [<span class="string">"Offset of field: mrb_state::symcapa"</span>] [:: std :: mem :: offset_of ! (mrb_state , symcapa) - <span class="number">9544usize</span>] ; [<span class="string">"Offset of field: mrb_state::symbuf"</span>] [:: std :: mem :: offset_of ! (mrb_state , symbuf) - <span class="number">9552usize</span>] ; [<span class="string">"Offset of field: mrb_state::eException_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , eException_class) - <span class="number">9560usize</span>] ; [<span class="string">"Offset of field: mrb_state::eStandardError_class"</span>] [:: std :: mem :: offset_of ! (mrb_state , eStandardError_class) - <span class="number">9568usize</span>] ; [<span class="string">"Offset of field: mrb_state::nomem_err"</span>] [:: std :: mem :: offset_of ! (mrb_state , nomem_err) - <span class="number">9576usize</span>] ; [<span class="string">"Offset of field: mrb_state::stack_err"</span>] [:: std :: mem :: offset_of ! (mrb_state , stack_err) - <span class="number">9584usize</span>] ; [<span class="string">"Offset of field: mrb_state::ud"</span>] [:: std :: mem :: offset_of ! (mrb_state , ud) - <span class="number">9592usize</span>] ; [<span class="string">"Offset of field: mrb_state::atexit_stack"</span>] [:: std :: mem :: offset_of ! (mrb_state , atexit_stack) - <span class="number">9600usize</span>] ; [<span class="string">"Offset of field: mrb_state::atexit_stack_len"</span>] [:: std :: mem :: offset_of ! (mrb_state , atexit_stack_len) - <span class="number">9608usize</span>] ; } ; <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_class (mrb : * <span class="kw-2">mut </span>mrb_state , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , super_ : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_class_id (mrb : * <span class="kw-2">mut </span>mrb_state , name : mrb_sym , super_ : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_module (mrb : * <span class="kw-2">mut </span>mrb_state , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_module_id (mrb : * <span class="kw-2">mut </span>mrb_state , name : mrb_sym) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_singleton_class (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_singleton_class_ptr (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_include_module (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , included : * <span class="kw-2">mut </span>RClass) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_prepend_module (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , prepended : * <span class="kw-2">mut </span>RClass) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_method (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , func : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_method_id (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , mid : mrb_sym , func : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_class_method (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , fun : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_class_method_id (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : mrb_sym , fun : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_singleton_method (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RObject , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , fun : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_singleton_method_id (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RObject , name : mrb_sym , fun : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_module_function (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , fun : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_module_function_id (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : mrb_sym , fun : mrb_func_t , aspec : mrb_aspec) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_const (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , val : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_const_id (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : mrb_sym , val : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_undef_method (mrb : * <span class="kw-2">mut </span>mrb_state , cla : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_undef_method_id (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RClass , arg3 : mrb_sym) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_undef_class_method (mrb : * <span class="kw-2">mut </span>mrb_state , cls : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_undef_class_method_id (mrb : * <span class="kw-2">mut </span>mrb_state , cls : * <span class="kw-2">mut </span>RClass , name : mrb_sym) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_new (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_new (mrb : * <span class="kw-2">mut </span>mrb_state , super_ : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_module_new (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_defined (mrb : * <span class="kw-2">mut </span>mrb_state , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_defined_id (mrb : * <span class="kw-2">mut </span>mrb_state , name : mrb_sym) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_get (mrb : * <span class="kw-2">mut </span>mrb_state , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_get_id (mrb : * <span class="kw-2">mut </span>mrb_state , name : mrb_sym) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_exc_get_id (mrb : * <span class="kw-2">mut </span>mrb_state , name : mrb_sym) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_defined_under (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_defined_under_id (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : mrb_sym) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_get_under (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_get_under_id (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : mrb_sym) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_module_get (mrb : * <span class="kw-2">mut </span>mrb_state , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_module_get_id (mrb : * <span class="kw-2">mut </span>mrb_state , name : mrb_sym) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_module_get_under (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_module_get_under_id (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : mrb_sym) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_notimplement (arg1 : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_notimplement_m (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_dup (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_respond_to (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , mid : mrb_sym) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_class_under (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , super_ : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_class_under_id (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : mrb_sym , super_ : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_module_under (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_module_under_id (mrb : * <span class="kw-2">mut </span>mrb_state , outer : * <span class="kw-2">mut </span>RClass , name : mrb_sym) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">pub type </span>mrb_args_format = * <span class="kw">const </span>:: std :: os :: raw :: c_char ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_kwargs { <span class="kw">pub </span>num : mrb_int , <span class="kw">pub </span>required : mrb_int , <span class="kw">pub </span>table : * <span class="kw">const </span>mrb_sym , <span class="kw">pub </span>values : * <span class="kw-2">mut </span>mrb_value , <span class="kw">pub </span>rest : * <span class="kw-2">mut </span>mrb_value , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_kwargs"</span>] [:: std :: mem :: size_of :: &lt; mrb_kwargs &gt; () - <span class="number">40usize</span>] ; [<span class="string">"Alignment of mrb_kwargs"</span>] [:: std :: mem :: align_of :: &lt; mrb_kwargs &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_kwargs::num"</span>] [:: std :: mem :: offset_of ! (mrb_kwargs , num) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_kwargs::required"</span>] [:: std :: mem :: offset_of ! (mrb_kwargs , required) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_kwargs::table"</span>] [:: std :: mem :: offset_of ! (mrb_kwargs , table) - <span class="number">16usize</span>] ; [<span class="string">"Offset of field: mrb_kwargs::values"</span>] [:: std :: mem :: offset_of ! (mrb_kwargs , values) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: mrb_kwargs::rest"</span>] [:: std :: mem :: offset_of ! (mrb_kwargs , rest) - <span class="number">32usize</span>] ; } ; <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_get_args (mrb : * <span class="kw-2">mut </span>mrb_state , format : mrb_args_format , ...) -&gt; mrb_int ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_get_args_a (mrb : * <span class="kw-2">mut </span>mrb_state , format : mrb_args_format , ptr : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; mrb_int ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_get_argc (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; mrb_int ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_get_argv (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; * <span class="kw">const </span>mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_get_arg1 (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_block_given_p (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_funcall (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , argc : mrb_int , ...) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_funcall_id (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value , mid : mrb_sym , argc : mrb_int , ...) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_funcall_argv (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value , name : mrb_sym , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_funcall_with_block (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value , name : mrb_sym , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value , block : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_intern_cstr (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_sym ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_intern (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg3 : usize) -&gt; mrb_sym ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_intern_static (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg3 : usize) -&gt; mrb_sym ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_intern_str (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value) -&gt; mrb_sym ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_intern_check_cstr (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_sym ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_intern_check (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg3 : usize) -&gt; mrb_sym ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_intern_check_str (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value) -&gt; mrb_sym ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_check_intern_cstr (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_check_intern (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg3 : usize) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_check_intern_str (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sym_name (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_sym) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sym_name_len (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_sym , arg3 : * <span class="kw-2">mut </span>mrb_int) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sym_dump (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_sym) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sym_str (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_sym) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_malloc (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_calloc (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : usize , arg3 : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_realloc (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , arg3 : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_realloc_simple (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , arg3 : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_malloc_simple (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_alloc (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_vtype , arg3 : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw-2">mut </span>RBasic ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_free (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_new (mrb : * <span class="kw-2">mut </span>mrb_state , p : * <span class="kw">const </span>:: std :: os :: raw :: c_char , len : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_new_cstr (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_new_static (mrb : * <span class="kw-2">mut </span>mrb_state , p : * <span class="kw">const </span>:: std :: os :: raw :: c_char , len : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_freeze (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_open () -&gt; * <span class="kw-2">mut </span>mrb_state ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_open_allocf (f : mrb_allocf , ud : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; * <span class="kw-2">mut </span>mrb_state ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_open_core (f : mrb_allocf , ud : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; * <span class="kw-2">mut </span>mrb_state ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_close (mrb : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_default_allocf (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , arg3 : usize , arg4 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_top_self (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_top_run (mrb : * <span class="kw-2">mut </span>mrb_state , proc_ : * <span class="kw">const </span>RProc , self_ : mrb_value , stack_keep : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vm_run (mrb : * <span class="kw-2">mut </span>mrb_state , proc_ : * <span class="kw">const </span>RProc , self_ : mrb_value , stack_keep : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vm_exec (mrb : * <span class="kw-2">mut </span>mrb_state , proc_ : * <span class="kw">const </span>RProc , iseq : * <span class="kw">const </span>mrb_code) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_p (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_id (obj : mrb_value) -&gt; mrb_int ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_to_sym (mrb : * <span class="kw-2">mut </span>mrb_state , name : mrb_value) -&gt; mrb_sym ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_eq (mrb : * <span class="kw-2">mut </span>mrb_state , a : mrb_value , b : mrb_value) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_equal (mrb : * <span class="kw-2">mut </span>mrb_state , a : mrb_value , b : mrb_value) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_equal (mrb : * <span class="kw-2">mut </span>mrb_state , obj1 : mrb_value , obj2 : mrb_value) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ensure_float_type (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_inspect (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_eql (mrb : * <span class="kw-2">mut </span>mrb_state , obj1 : mrb_value , obj2 : mrb_value) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_cmp (mrb : * <span class="kw-2">mut </span>mrb_state , obj1 : mrb_value , obj2 : mrb_value) -&gt; mrb_int ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_garbage_collect (arg1 : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_full_gc (arg1 : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_incremental_gc (arg1 : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_gc_mark (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RBasic) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_field_write_barrier (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RBasic , arg3 : * <span class="kw-2">mut </span>RBasic) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_write_barrier (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RBasic) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_type_convert (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value , type_ : mrb_vtype , method : mrb_sym) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_type_convert_check (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value , type_ : mrb_vtype , method : mrb_sym) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_any_to_s (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_classname (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_class (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_path (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_is_kind_of (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , c : * <span class="kw-2">mut </span>RClass) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_inspect (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_clone (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_exc_new (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , ptr : * <span class="kw">const </span>:: std :: os :: raw :: c_char , len : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_exc_raise (mrb : * <span class="kw-2">mut </span>mrb_state , exc : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_raise (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , msg : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_raisef (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , fmt : * <span class="kw">const </span>:: std :: os :: raw :: c_char , ...) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_name_error (mrb : * <span class="kw-2">mut </span>mrb_state , id : mrb_sym , fmt : * <span class="kw">const </span>:: std :: os :: raw :: c_char , ...) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_frozen_error (mrb : * <span class="kw-2">mut </span>mrb_state , frozen_obj : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_argnum_error (mrb : * <span class="kw-2">mut </span>mrb_state , argc : mrb_int , min : :: std :: os :: raw :: c_int , max : :: std :: os :: raw :: c_int) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_warn (mrb : * <span class="kw-2">mut </span>mrb_state , fmt : * <span class="kw">const </span>:: std :: os :: raw :: c_char , ...) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_bug (mrb : * <span class="kw-2">mut </span>mrb_state , fmt : * <span class="kw">const </span>:: std :: os :: raw :: c_char , ...) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_print_backtrace (mrb : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_print_error (mrb : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vformat (mrb : * <span class="kw-2">mut </span>mrb_state , format : * <span class="kw">const </span>:: std :: os :: raw :: c_char , ap : * <span class="kw-2">mut </span>__va_list_tag) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_yield (mrb : * <span class="kw-2">mut </span>mrb_state , b : mrb_value , arg : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_yield_argv (mrb : * <span class="kw-2">mut </span>mrb_state , b : mrb_value , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_yield_with_class (mrb : * <span class="kw-2">mut </span>mrb_state , b : mrb_value , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value , self_ : mrb_value , c : * <span class="kw-2">mut </span>RClass) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_yield_cont (mrb : * <span class="kw-2">mut </span>mrb_state , b : mrb_value , self_ : mrb_value , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_gc_protect (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_gc_register (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_gc_unregister (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ensure_array_type (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_check_array_type (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ensure_hash_type (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_check_hash_type (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ensure_string_type (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_check_string_type (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ensure_integer_type (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ensure_int_type (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_check_type (mrb : * <span class="kw-2">mut </span>mrb_state , x : mrb_value , t : mrb_vtype) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_alias (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , a : * <span class="kw">const </span>:: std :: os :: raw :: c_char , b : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_alias_id (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , a : mrb_sym , b : mrb_sym) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_name (mrb : * <span class="kw-2">mut </span>mrb_state , klass : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_global_const (mrb : * <span class="kw-2">mut </span>mrb_state , name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , val : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_attr_get (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , id : mrb_sym) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_respond_to (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , mid : mrb_sym) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_is_instance_of (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , c : * <span class="kw-2">mut </span>RClass) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_func_basic_p (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , mid : mrb_sym , func : mrb_func_t) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_fiber_resume (mrb : * <span class="kw-2">mut </span>mrb_state , fib : mrb_value , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_fiber_yield (mrb : * <span class="kw-2">mut </span>mrb_state , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_fiber_alive_p (mrb : * <span class="kw-2">mut </span>mrb_state , fib : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_stack_extend (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_int) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_pool { _unused : [u8 ; <span class="number">0</span>] , } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_pool_open (arg1 : * <span class="kw-2">mut </span>mrb_state) -&gt; * <span class="kw-2">mut </span>mrb_pool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_pool_close (arg1 : * <span class="kw-2">mut </span>mrb_pool) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_pool_alloc (arg1 : * <span class="kw-2">mut </span>mrb_pool , arg2 : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_pool_realloc (arg1 : * <span class="kw-2">mut </span>mrb_pool , arg2 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , oldlen : usize , newlen : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_pool_can_realloc (arg1 : * <span class="kw-2">mut </span>mrb_pool , arg2 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , arg3 : usize) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_alloca (mrb : * <span class="kw-2">mut </span>mrb_state , arg1 : usize) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_state_atexit (mrb : * <span class="kw-2">mut </span>mrb_state , func : mrb_atexit_func) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_show_version (mrb : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_show_copyright (mrb : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_format (mrb : * <span class="kw-2">mut </span>mrb_state , format : * <span class="kw">const </span>:: std :: os :: raw :: c_char , ...) -&gt; mrb_value ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_shared_array { <span class="kw">pub </span>refcnt : :: std :: os :: raw :: c_int , <span class="kw">pub </span>len : mrb_ssize , <span class="kw">pub </span>ptr : * <span class="kw-2">mut </span>mrb_value , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_shared_array"</span>] [:: std :: mem :: size_of :: &lt; mrb_shared_array &gt; () - <span class="number">24usize</span>] ; [<span class="string">"Alignment of mrb_shared_array"</span>] [:: std :: mem :: align_of :: &lt; mrb_shared_array &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_shared_array::refcnt"</span>] [:: std :: mem :: offset_of ! (mrb_shared_array , refcnt) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_shared_array::len"</span>] [:: std :: mem :: offset_of ! (mrb_shared_array , len) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_shared_array::ptr"</span>] [:: std :: mem :: offset_of ! (mrb_shared_array , ptr) - <span class="number">16usize</span>] ; } ; # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>RArray { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>as_ : RArray__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>RArray__bindgen_ty_1 { <span class="kw">pub </span>heap : RArray__bindgen_ty_1__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>RArray__bindgen_ty_1__bindgen_ty_1 { <span class="kw">pub </span>len : mrb_ssize , <span class="kw">pub </span>aux : RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , <span class="kw">pub </span>ptr : * <span class="kw-2">mut </span>mrb_value , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { <span class="kw">pub </span>capa : mrb_ssize , <span class="kw">pub </span>shared : * <span class="kw-2">mut </span>mrb_shared_array , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"</span>] [:: std :: mem :: size_of :: &lt; RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Alignment of RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"</span>] [:: std :: mem :: align_of :: &lt; RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::capa"</span>] [:: std :: mem :: offset_of ! (RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , capa) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::shared"</span>] [:: std :: mem :: offset_of ! (RArray__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , shared) - <span class="number">0usize</span>] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RArray__bindgen_ty_1__bindgen_ty_1"</span>] [:: std :: mem :: size_of :: &lt; RArray__bindgen_ty_1__bindgen_ty_1 &gt; () - <span class="number">24usize</span>] ; [<span class="string">"Alignment of RArray__bindgen_ty_1__bindgen_ty_1"</span>] [:: std :: mem :: align_of :: &lt; RArray__bindgen_ty_1__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RArray__bindgen_ty_1__bindgen_ty_1::len"</span>] [:: std :: mem :: offset_of ! (RArray__bindgen_ty_1__bindgen_ty_1 , len) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RArray__bindgen_ty_1__bindgen_ty_1::aux"</span>] [:: std :: mem :: offset_of ! (RArray__bindgen_ty_1__bindgen_ty_1 , aux) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RArray__bindgen_ty_1__bindgen_ty_1::ptr"</span>] [:: std :: mem :: offset_of ! (RArray__bindgen_ty_1__bindgen_ty_1 , ptr) - <span class="number">16usize</span>] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RArray__bindgen_ty_1"</span>] [:: std :: mem :: size_of :: &lt; RArray__bindgen_ty_1 &gt; () - <span class="number">24usize</span>] ; [<span class="string">"Alignment of RArray__bindgen_ty_1"</span>] [:: std :: mem :: align_of :: &lt; RArray__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RArray__bindgen_ty_1::heap"</span>] [:: std :: mem :: offset_of ! (RArray__bindgen_ty_1 , heap) - <span class="number">0usize</span>] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RArray"</span>] [:: std :: mem :: size_of :: &lt; RArray &gt; () - <span class="number">48usize</span>] ; [<span class="string">"Alignment of RArray"</span>] [:: std :: mem :: align_of :: &lt; RArray &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RArray::c"</span>] [:: std :: mem :: offset_of ! (RArray , c) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RArray::gcnext"</span>] [:: std :: mem :: offset_of ! (RArray , gcnext) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RArray::as_"</span>] [:: std :: mem :: offset_of ! (RArray , as_) - <span class="number">24usize</span>] ; } ; <span class="kw">impl </span>RArray { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>tt_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_tt_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>color_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_color_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>flags_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_flags_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_modify (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RArray) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_new_capa (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_new (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_new_from_values (mrb : * <span class="kw-2">mut </span>mrb_state , size : mrb_int , vals : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_assoc_new (mrb : * <span class="kw-2">mut </span>mrb_state , car : mrb_value , cdr : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_concat (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value , other : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_splat (mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_push (mrb : * <span class="kw-2">mut </span>mrb_state , array : mrb_value , value : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_pop (mrb : * <span class="kw-2">mut </span>mrb_state , ary : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_set (mrb : * <span class="kw-2">mut </span>mrb_state , ary : mrb_value , n : mrb_int , val : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_replace (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value , other : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_unshift (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value , item : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_entry (ary : mrb_value , offset : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_splice (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value , head : mrb_int , len : mrb_int , rpl : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_shift (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_clear (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_join (mrb : * <span class="kw-2">mut </span>mrb_state , ary : mrb_value , sep : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_resize (mrb : * <span class="kw-2">mut </span>mrb_state , ary : mrb_value , new_len : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ary_artichoke_free (mrb : * <span class="kw-2">mut </span>mrb_state , ary : * <span class="kw-2">mut </span>RArray) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>RClass { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>iv : * <span class="kw-2">mut </span>iv_tbl , <span class="kw">pub </span>mt : * <span class="kw-2">mut </span>mt_tbl , <span class="kw">pub </span>super_ : * <span class="kw-2">mut </span>RClass , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RClass"</span>] [:: std :: mem :: size_of :: &lt; RClass &gt; () - <span class="number">48usize</span>] ; [<span class="string">"Alignment of RClass"</span>] [:: std :: mem :: align_of :: &lt; RClass &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RClass::c"</span>] [:: std :: mem :: offset_of ! (RClass , c) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RClass::gcnext"</span>] [:: std :: mem :: offset_of ! (RClass , gcnext) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RClass::iv"</span>] [:: std :: mem :: offset_of ! (RClass , iv) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: RClass::mt"</span>] [:: std :: mem :: offset_of ! (RClass , mt) - <span class="number">32usize</span>] ; [<span class="string">"Offset of field: RClass::super_"</span>] [:: std :: mem :: offset_of ! (RClass , super_) - <span class="number">40usize</span>] ; } ; <span class="kw">impl </span>RClass { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>tt_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_tt_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>color_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_color_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>flags_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_flags_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_define_method_raw (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RClass , arg3 : mrb_sym , arg4 : mrb_method_t) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_alias_method (arg1 : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , a : mrb_sym , b : mrb_sym) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_remove_method (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , sym : mrb_sym) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_method_search_vm (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>RClass , arg3 : mrb_sym) -&gt; mrb_method_t ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_method_search (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RClass , arg3 : mrb_sym) -&gt; mrb_method_t ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_class_real (cl : * <span class="kw-2">mut </span>RClass) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_mc_clear_by_class (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass) ; } <span class="kw">pub type </span>mrb_mt_foreach_func = :: std :: option :: <span class="prelude-ty">Option</span> &lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_sym , arg3 : mrb_method_t , arg4 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; :: std :: os :: raw :: c_int &gt; ; <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_mt_foreach (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>RClass , arg3 : mrb_mt_foreach_func , arg4 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrbc_context { <span class="kw">pub </span>syms : * <span class="kw-2">mut </span>mrb_sym , <span class="kw">pub </span>slen : :: std :: os :: raw :: c_int , <span class="kw">pub </span>filename : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>lineno : u16 , <span class="kw">pub </span>partial_hook : :: std :: option :: <span class="prelude-ty">Option</span> &lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(arg1 : * <span class="kw-2">mut </span>mrb_parser_state) -&gt; :: std :: os :: raw :: c_int &gt; , <span class="kw">pub </span>partial_data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , <span class="kw">pub </span>target_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>_bitfield_align_1 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>upper : * <span class="kw">const </span>RProc , <span class="kw">pub </span>parser_nerr : usize , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrbc_context"</span>] [:: std :: mem :: size_of :: &lt; mrbc_context &gt; () - <span class="number">80usize</span>] ; [<span class="string">"Alignment of mrbc_context"</span>] [:: std :: mem :: align_of :: &lt; mrbc_context &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrbc_context::syms"</span>] [:: std :: mem :: offset_of ! (mrbc_context , syms) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrbc_context::slen"</span>] [:: std :: mem :: offset_of ! (mrbc_context , slen) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrbc_context::filename"</span>] [:: std :: mem :: offset_of ! (mrbc_context , filename) - <span class="number">16usize</span>] ; [<span class="string">"Offset of field: mrbc_context::lineno"</span>] [:: std :: mem :: offset_of ! (mrbc_context , lineno) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: mrbc_context::partial_hook"</span>] [:: std :: mem :: offset_of ! (mrbc_context , partial_hook) - <span class="number">32usize</span>] ; [<span class="string">"Offset of field: mrbc_context::partial_data"</span>] [:: std :: mem :: offset_of ! (mrbc_context , partial_data) - <span class="number">40usize</span>] ; [<span class="string">"Offset of field: mrbc_context::target_class"</span>] [:: std :: mem :: offset_of ! (mrbc_context , target_class) - <span class="number">48usize</span>] ; [<span class="string">"Offset of field: mrbc_context::upper"</span>] [:: std :: mem :: offset_of ! (mrbc_context , upper) - <span class="number">64usize</span>] ; [<span class="string">"Offset of field: mrbc_context::parser_nerr"</span>] [:: std :: mem :: offset_of ! (mrbc_context , parser_nerr) - <span class="number">72usize</span>] ; } ; <span class="kw">impl </span>mrbc_context { # [inline] <span class="kw">pub fn </span>capture_errors (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_capture_errors (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>capture_errors_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_capture_errors_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>dump_result (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">1usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_dump_result (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>dump_result_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">1usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_dump_result_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">1usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>no_exec (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">2usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_no_exec (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>no_exec_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">2usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_no_exec_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">2usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>keep_lv (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">3usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_keep_lv (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">3usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>keep_lv_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">3usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_keep_lv_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">3usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>no_optimize (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">4usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_no_optimize (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">4usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>no_optimize_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">4usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_no_optimize_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">4usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>no_ext_ops (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">5usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_no_ext_ops (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">5usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>no_ext_ops_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">5usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_no_ext_ops_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">5usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (capture_errors : mrb_bool , dump_result : mrb_bool , no_exec : mrb_bool , keep_lv : mrb_bool , no_optimize : mrb_bool , no_ext_ops : mrb_bool) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>capture_errors : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (capture_errors) } ; capture_errors <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>dump_result : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (dump_result) } ; dump_result <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>no_exec : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (no_exec) } ; no_exec <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">3usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>keep_lv : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (keep_lv) } ; keep_lv <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">4usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>no_optimize : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (no_optimize) } ; no_optimize <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">5usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>no_ext_ops : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (no_ext_ops) } ; no_ext_ops <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrbc_context_new (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; * <span class="kw-2">mut </span>mrbc_context ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrbc_context_free (mrb : * <span class="kw-2">mut </span>mrb_state , cxt : * <span class="kw-2">mut </span>mrbc_context) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrbc_filename (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>mrbc_context , s : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrbc_partial_hook (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>mrbc_context , partial_hook : :: std :: option :: <span class="prelude-ty">Option</span> &lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(arg1 : * <span class="kw-2">mut </span>mrb_parser_state) -&gt; :: std :: os :: raw :: c_int &gt; , data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrbc_cleanup_local_variables (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>mrbc_context) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_ast_node { <span class="kw">pub </span>car : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>cdr : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>lineno : u16 , <span class="kw">pub </span>filename_index : u16 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_ast_node"</span>] [:: std :: mem :: size_of :: &lt; mrb_ast_node &gt; () - <span class="number">24usize</span>] ; [<span class="string">"Alignment of mrb_ast_node"</span>] [:: std :: mem :: align_of :: &lt; mrb_ast_node &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_ast_node::car"</span>] [:: std :: mem :: offset_of ! (mrb_ast_node , car) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_ast_node::cdr"</span>] [:: std :: mem :: offset_of ! (mrb_ast_node , cdr) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_ast_node::lineno"</span>] [:: std :: mem :: offset_of ! (mrb_ast_node , lineno) - <span class="number">16usize</span>] ; [<span class="string">"Offset of field: mrb_ast_node::filename_index"</span>] [:: std :: mem :: offset_of ! (mrb_ast_node , filename_index) - <span class="number">18usize</span>] ; } ; # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_lex_state_enum { EXPR_BEG = <span class="number">0 </span>, EXPR_END = <span class="number">1 </span>, EXPR_ENDARG = <span class="number">2 </span>, EXPR_ENDFN = <span class="number">3 </span>, EXPR_ARG = <span class="number">4 </span>, EXPR_CMDARG = <span class="number">5 </span>, EXPR_MID = <span class="number">6 </span>, EXPR_FNAME = <span class="number">7 </span>, EXPR_DOT = <span class="number">8 </span>, EXPR_CLASS = <span class="number">9 </span>, EXPR_VALUE = <span class="number">10 </span>, EXPR_MAX_STATE = <span class="number">11 </span>, } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_parser_message { <span class="kw">pub </span>lineno : u16 , <span class="kw">pub </span>column : :: std :: os :: raw :: c_int , <span class="kw">pub </span>message : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_parser_message"</span>] [:: std :: mem :: size_of :: &lt; mrb_parser_message &gt; () - <span class="number">16usize</span>] ; [<span class="string">"Alignment of mrb_parser_message"</span>] [:: std :: mem :: align_of :: &lt; mrb_parser_message &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_parser_message::lineno"</span>] [:: std :: mem :: offset_of ! (mrb_parser_message , lineno) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_parser_message::column"</span>] [:: std :: mem :: offset_of ! (mrb_parser_message , column) - <span class="number">4usize</span>] ; [<span class="string">"Offset of field: mrb_parser_message::message"</span>] [:: std :: mem :: offset_of ! (mrb_parser_message , message) - <span class="number">8usize</span>] ; } ; # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_string_type { str_not_parsing = <span class="number">0 </span>, str_squote = <span class="number">1 </span>, str_dquote = <span class="number">3 </span>, str_regexp = <span class="number">7 </span>, str_sword = <span class="number">41 </span>, str_dword = <span class="number">43 </span>, str_ssym = <span class="number">17 </span>, str_ssymbols = <span class="number">49 </span>, str_dsymbols = <span class="number">51 </span>, str_heredoc = <span class="number">65 </span>, str_xquote = <span class="number">131 </span>, } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_parser_heredoc_info { <span class="kw">pub </span>_bitfield_align_1 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>indent : usize , <span class="kw">pub </span>indented : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>type_ : mrb_string_type , <span class="kw">pub </span>term : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>term_len : :: std :: os :: raw :: c_int , <span class="kw">pub </span>doc : * <span class="kw-2">mut </span>mrb_ast_node , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_parser_heredoc_info"</span>] [:: std :: mem :: size_of :: &lt; mrb_parser_heredoc_info &gt; () - <span class="number">56usize</span>] ; [<span class="string">"Alignment of mrb_parser_heredoc_info"</span>] [:: std :: mem :: align_of :: &lt; mrb_parser_heredoc_info &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_parser_heredoc_info::indent"</span>] [:: std :: mem :: offset_of ! (mrb_parser_heredoc_info , indent) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_parser_heredoc_info::indented"</span>] [:: std :: mem :: offset_of ! (mrb_parser_heredoc_info , indented) - <span class="number">16usize</span>] ; [<span class="string">"Offset of field: mrb_parser_heredoc_info::type_"</span>] [:: std :: mem :: offset_of ! (mrb_parser_heredoc_info , type_) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: mrb_parser_heredoc_info::term"</span>] [:: std :: mem :: offset_of ! (mrb_parser_heredoc_info , term) - <span class="number">32usize</span>] ; [<span class="string">"Offset of field: mrb_parser_heredoc_info::term_len"</span>] [:: std :: mem :: offset_of ! (mrb_parser_heredoc_info , term_len) - <span class="number">40usize</span>] ; [<span class="string">"Offset of field: mrb_parser_heredoc_info::doc"</span>] [:: std :: mem :: offset_of ! (mrb_parser_heredoc_info , doc) - <span class="number">48usize</span>] ; } ; <span class="kw">impl </span>mrb_parser_heredoc_info { # [inline] <span class="kw">pub fn </span>allow_indent (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_allow_indent (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>allow_indent_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_allow_indent_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>remove_indent (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">1usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_remove_indent (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>remove_indent_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">1usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_remove_indent_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">1usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>line_head (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">2usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_line_head (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>line_head_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">2usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_line_head_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">2usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (allow_indent : mrb_bool , remove_indent : mrb_bool , line_head : mrb_bool) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>allow_indent : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (allow_indent) } ; allow_indent <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>remove_indent : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (remove_indent) } ; remove_indent <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>line_head : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (line_head) } ; line_head <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_parser_state { <span class="kw">pub </span>mrb : * <span class="kw-2">mut </span>mrb_state , <span class="kw">pub </span>pool : * <span class="kw-2">mut </span>mrb_pool , <span class="kw">pub </span>cells : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>s : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>send : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>cxt : * <span class="kw-2">mut </span>mrbc_context , <span class="kw">pub </span>filename_sym : mrb_sym , <span class="kw">pub </span>lineno : u16 , <span class="kw">pub </span>column : :: std :: os :: raw :: c_int , <span class="kw">pub </span>lstate : mrb_lex_state_enum , <span class="kw">pub </span>lex_strterm : * <span class="kw-2">mut </span>parser_lex_strterm , <span class="kw">pub </span>cond_stack : :: std :: os :: raw :: c_uint , <span class="kw">pub </span>cmdarg_stack : :: std :: os :: raw :: c_uint , <span class="kw">pub </span>paren_nest : :: std :: os :: raw :: c_int , <span class="kw">pub </span>lpar_beg : :: std :: os :: raw :: c_int , <span class="kw">pub </span>in_def : :: std :: os :: raw :: c_int , <span class="kw">pub </span>in_single : :: std :: os :: raw :: c_int , <span class="kw">pub </span>_bitfield_align_1 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>locals : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>pb : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>tokbuf : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>buf : [:: std :: os :: raw :: c_char ; <span class="number">256usize</span>] , <span class="kw">pub </span>tidx : :: std :: os :: raw :: c_int , <span class="kw">pub </span>tsiz : :: std :: os :: raw :: c_int , <span class="kw">pub </span>heredocs_from_nextline : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>parsing_heredoc : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>ylval : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , <span class="kw">pub </span>nerr : usize , <span class="kw">pub </span>nwarn : usize , <span class="kw">pub </span>tree : * <span class="kw-2">mut </span>mrb_ast_node , <span class="kw">pub </span>_bitfield_align_2 : [u8 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_2 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; , <span class="kw">pub </span>upper : * <span class="kw">const </span>RProc , <span class="kw">pub </span>error_buffer : [mrb_parser_message ; <span class="number">10usize</span>] , <span class="kw">pub </span>warn_buffer : [mrb_parser_message ; <span class="number">10usize</span>] , <span class="kw">pub </span>filename_table : * <span class="kw-2">mut </span>mrb_sym , <span class="kw">pub </span>filename_table_length : u16 , <span class="kw">pub </span>current_filename_index : u16 , <span class="kw">pub </span>nvars : * <span class="kw-2">mut </span>mrb_ast_node , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_parser_state"</span>] [:: std :: mem :: size_of :: &lt; mrb_parser_state &gt; () - <span class="number">800usize</span>] ; [<span class="string">"Alignment of mrb_parser_state"</span>] [:: std :: mem :: align_of :: &lt; mrb_parser_state &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::mrb"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , mrb) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::pool"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , pool) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::cells"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , cells) - <span class="number">16usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::s"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , s) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::send"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , send) - <span class="number">32usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::cxt"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , cxt) - <span class="number">40usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::filename_sym"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , filename_sym) - <span class="number">48usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::lineno"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , lineno) - <span class="number">52usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::column"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , column) - <span class="number">56usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::lstate"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , lstate) - <span class="number">60usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::lex_strterm"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , lex_strterm) - <span class="number">64usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::cond_stack"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , cond_stack) - <span class="number">72usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::cmdarg_stack"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , cmdarg_stack) - <span class="number">76usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::paren_nest"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , paren_nest) - <span class="number">80usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::lpar_beg"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , lpar_beg) - <span class="number">84usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::in_def"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , in_def) - <span class="number">88usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::in_single"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , in_single) - <span class="number">92usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::locals"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , locals) - <span class="number">104usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::pb"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , pb) - <span class="number">112usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::tokbuf"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , tokbuf) - <span class="number">120usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::buf"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , buf) - <span class="number">128usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::tidx"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , tidx) - <span class="number">384usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::tsiz"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , tsiz) - <span class="number">388usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::heredocs_from_nextline"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , heredocs_from_nextline) - <span class="number">392usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::parsing_heredoc"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , parsing_heredoc) - <span class="number">400usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::ylval"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , ylval) - <span class="number">408usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::nerr"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , nerr) - <span class="number">416usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::nwarn"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , nwarn) - <span class="number">424usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::tree"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , tree) - <span class="number">432usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::upper"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , upper) - <span class="number">448usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::error_buffer"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , error_buffer) - <span class="number">456usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::warn_buffer"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , warn_buffer) - <span class="number">616usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::filename_table"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , filename_table) - <span class="number">776usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::filename_table_length"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , filename_table_length) - <span class="number">784usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::current_filename_index"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , current_filename_index) - <span class="number">786usize</span>] ; [<span class="string">"Offset of field: mrb_parser_state::nvars"</span>] [:: std :: mem :: offset_of ! (mrb_parser_state , nvars) - <span class="number">792usize</span>] ; } ; <span class="kw">impl </span>mrb_parser_state { # [inline] <span class="kw">pub fn </span>cmd_start (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_cmd_start (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>cmd_start_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_cmd_start_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (cmd_start : mrb_bool) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>cmd_start : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (cmd_start) } ; cmd_start <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } # [inline] <span class="kw">pub fn </span>no_optimize (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_2 . get (<span class="number">0usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_no_optimize (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_2 . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>no_optimize_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_2) , <span class="number">0usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_no_optimize_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_2) , <span class="number">0usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>capture_errors (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_2 . get (<span class="number">1usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_capture_errors (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_2 . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>capture_errors_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_2) , <span class="number">1usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_capture_errors_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_2) , <span class="number">1usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>no_ext_ops (&amp; <span class="self">self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_2 . get (<span class="number">2usize </span>, <span class="number">1u8</span>) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub fn </span>set_no_ext_ops (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_2 . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>no_ext_ops_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_bool { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_2) , <span class="number">2usize </span>, <span class="number">1u8 </span>,) <span class="kw">as </span>u8) } } # [inline] <span class="kw">pub unsafe fn </span>set_no_ext_ops_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_bool) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u8 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_2) , <span class="number">2usize </span>, <span class="number">1u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_2 (no_optimize : mrb_bool , capture_errors : mrb_bool , no_ext_ops : mrb_bool) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">1usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>no_optimize : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (no_optimize) } ; no_optimize <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">1usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>capture_errors : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (capture_errors) } ; capture_errors <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">2usize </span>, <span class="number">1u8 </span>, { <span class="kw">let </span>no_ext_ops : u8 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (no_ext_ops) } ; no_ext_ops <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_parser_new (arg1 : * <span class="kw-2">mut </span>mrb_state) -&gt; * <span class="kw-2">mut </span>mrb_parser_state ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_parser_free (arg1 : * <span class="kw-2">mut </span>mrb_parser_state) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_parser_parse (arg1 : * <span class="kw-2">mut </span>mrb_parser_state , arg2 : * <span class="kw-2">mut </span>mrbc_context) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_parser_set_filename (arg1 : * <span class="kw-2">mut </span>mrb_parser_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_parser_get_filename (arg1 : * <span class="kw-2">mut </span>mrb_parser_state , idx : u16) -&gt; mrb_sym ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_parse_string (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg3 : * <span class="kw-2">mut </span>mrbc_context) -&gt; * <span class="kw-2">mut </span>mrb_parser_state ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_parse_nstring (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_char , arg3 : usize , arg4 : * <span class="kw-2">mut </span>mrbc_context) -&gt; * <span class="kw-2">mut </span>mrb_parser_state ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_generate_code (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>mrb_parser_state) -&gt; * <span class="kw-2">mut </span>RProc ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_exec (mrb : * <span class="kw-2">mut </span>mrb_state , p : * <span class="kw-2">mut </span>mrb_parser_state , c : * <span class="kw-2">mut </span>mrbc_context) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_string (mrb : * <span class="kw-2">mut </span>mrb_state , s : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_nstring (mrb : * <span class="kw-2">mut </span>mrb_state , s : * <span class="kw">const </span>:: std :: os :: raw :: c_char , len : usize) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_string_cxt (mrb : * <span class="kw-2">mut </span>mrb_state , s : * <span class="kw">const </span>:: std :: os :: raw :: c_char , cxt : * <span class="kw-2">mut </span>mrbc_context) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_nstring_cxt (mrb : * <span class="kw-2">mut </span>mrb_state , s : * <span class="kw">const </span>:: std :: os :: raw :: c_char , len : usize , cxt : * <span class="kw-2">mut </span>mrbc_context) -&gt; mrb_value ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_data_type { <span class="kw">pub </span>struct_name : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>dfree : :: std :: option :: <span class="prelude-ty">Option</span> &lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(mrb : * <span class="kw-2">mut </span>mrb_state , arg1 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) &gt; , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_data_type"</span>] [:: std :: mem :: size_of :: &lt; mrb_data_type &gt; () - <span class="number">16usize</span>] ; [<span class="string">"Alignment of mrb_data_type"</span>] [:: std :: mem :: align_of :: &lt; mrb_data_type &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_data_type::struct_name"</span>] [:: std :: mem :: offset_of ! (mrb_data_type , struct_name) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_data_type::dfree"</span>] [:: std :: mem :: offset_of ! (mrb_data_type , dfree) - <span class="number">8usize</span>] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>RData { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>iv : * <span class="kw-2">mut </span>iv_tbl , <span class="kw">pub </span>type_ : * <span class="kw">const </span>mrb_data_type , <span class="kw">pub </span>data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RData"</span>] [:: std :: mem :: size_of :: &lt; RData &gt; () - <span class="number">48usize</span>] ; [<span class="string">"Alignment of RData"</span>] [:: std :: mem :: align_of :: &lt; RData &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RData::c"</span>] [:: std :: mem :: offset_of ! (RData , c) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RData::gcnext"</span>] [:: std :: mem :: offset_of ! (RData , gcnext) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RData::iv"</span>] [:: std :: mem :: offset_of ! (RData , iv) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: RData::type_"</span>] [:: std :: mem :: offset_of ! (RData , type_) - <span class="number">32usize</span>] ; [<span class="string">"Offset of field: RData::data"</span>] [:: std :: mem :: offset_of ! (RData , data) - <span class="number">40usize</span>] ; } ; <span class="kw">impl </span>RData { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>tt_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_tt_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>color_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_color_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>flags_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_flags_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_data_object_alloc (mrb : * <span class="kw-2">mut </span>mrb_state , klass : * <span class="kw-2">mut </span>RClass , datap : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , type_ : * <span class="kw">const </span>mrb_data_type) -&gt; * <span class="kw-2">mut </span>RData ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_data_check_type (mrb : * <span class="kw-2">mut </span>mrb_state , arg1 : mrb_value , arg2 : * <span class="kw">const </span>mrb_data_type) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_data_get_ptr (mrb : * <span class="kw-2">mut </span>mrb_state , arg1 : mrb_value , arg2 : * <span class="kw">const </span>mrb_data_type) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_data_check_get_ptr (mrb : * <span class="kw-2">mut </span>mrb_state , arg1 : mrb_value , arg2 : * <span class="kw">const </span>mrb_data_type) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>mrb_pool_value { <span class="kw">pub </span>tt : u32 , <span class="kw">pub </span>u : mrb_pool_value__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>mrb_pool_value__bindgen_ty_1 { <span class="kw">pub </span>str_ : * <span class="kw">const </span>:: std :: os :: raw :: c_char , <span class="kw">pub </span>i32_ : i32 , <span class="kw">pub </span>i64_ : i64 , <span class="kw">pub </span>f : mrb_float , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_pool_value__bindgen_ty_1"</span>] [:: std :: mem :: size_of :: &lt; mrb_pool_value__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Alignment of mrb_pool_value__bindgen_ty_1"</span>] [:: std :: mem :: align_of :: &lt; mrb_pool_value__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_pool_value__bindgen_ty_1::str_"</span>] [:: std :: mem :: offset_of ! (mrb_pool_value__bindgen_ty_1 , str_) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_pool_value__bindgen_ty_1::i32_"</span>] [:: std :: mem :: offset_of ! (mrb_pool_value__bindgen_ty_1 , i32_) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_pool_value__bindgen_ty_1::i64_"</span>] [:: std :: mem :: offset_of ! (mrb_pool_value__bindgen_ty_1 , i64_) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_pool_value__bindgen_ty_1::f"</span>] [:: std :: mem :: offset_of ! (mrb_pool_value__bindgen_ty_1 , f) - <span class="number">0usize</span>] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_pool_value"</span>] [:: std :: mem :: size_of :: &lt; mrb_pool_value &gt; () - <span class="number">16usize</span>] ; [<span class="string">"Alignment of mrb_pool_value"</span>] [:: std :: mem :: align_of :: &lt; mrb_pool_value &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_pool_value::tt"</span>] [:: std :: mem :: offset_of ! (mrb_pool_value , tt) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_pool_value::u"</span>] [:: std :: mem :: offset_of ! (mrb_pool_value , u) - <span class="number">8usize</span>] ; } ; # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_catch_type { MRB_CATCH_RESCUE = <span class="number">0 </span>, MRB_CATCH_ENSURE = <span class="number">1 </span>, } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_irep_catch_handler { <span class="kw">pub </span>type_ : u8 , <span class="kw">pub </span>begin : [u8 ; <span class="number">4usize</span>] , <span class="kw">pub </span>end : [u8 ; <span class="number">4usize</span>] , <span class="kw">pub </span>target : [u8 ; <span class="number">4usize</span>] , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_irep_catch_handler"</span>] [:: std :: mem :: size_of :: &lt; mrb_irep_catch_handler &gt; () - <span class="number">13usize</span>] ; [<span class="string">"Alignment of mrb_irep_catch_handler"</span>] [:: std :: mem :: align_of :: &lt; mrb_irep_catch_handler &gt; () - <span class="number">1usize</span>] ; [<span class="string">"Offset of field: mrb_irep_catch_handler::type_"</span>] [:: std :: mem :: offset_of ! (mrb_irep_catch_handler , type_) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_irep_catch_handler::begin"</span>] [:: std :: mem :: offset_of ! (mrb_irep_catch_handler , begin) - <span class="number">1usize</span>] ; [<span class="string">"Offset of field: mrb_irep_catch_handler::end"</span>] [:: std :: mem :: offset_of ! (mrb_irep_catch_handler , end) - <span class="number">5usize</span>] ; [<span class="string">"Offset of field: mrb_irep_catch_handler::target"</span>] [:: std :: mem :: offset_of ! (mrb_irep_catch_handler , target) - <span class="number">9usize</span>] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_irep { <span class="kw">pub </span>nlocals : u16 , <span class="kw">pub </span>nregs : u16 , <span class="kw">pub </span>clen : u16 , <span class="kw">pub </span>flags : u8 , <span class="kw">pub </span>iseq : * <span class="kw">const </span>mrb_code , <span class="kw">pub </span>pool : * <span class="kw">const </span>mrb_pool_value , <span class="kw">pub </span>syms : * <span class="kw">const </span>mrb_sym , <span class="kw">pub </span>reps : * <span class="kw">const </span>* <span class="kw">const </span>mrb_irep , <span class="kw">pub </span>lv : * <span class="kw">const </span>mrb_sym , <span class="kw">pub </span>debug_info : * <span class="kw-2">mut </span>mrb_irep_debug_info , <span class="kw">pub </span>ilen : u32 , <span class="kw">pub </span>plen : u16 , <span class="kw">pub </span>slen : u16 , <span class="kw">pub </span>rlen : u16 , <span class="kw">pub </span>refcnt : u16 , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_irep"</span>] [:: std :: mem :: size_of :: &lt; mrb_irep &gt; () - <span class="number">72usize</span>] ; [<span class="string">"Alignment of mrb_irep"</span>] [:: std :: mem :: align_of :: &lt; mrb_irep &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_irep::nlocals"</span>] [:: std :: mem :: offset_of ! (mrb_irep , nlocals) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_irep::nregs"</span>] [:: std :: mem :: offset_of ! (mrb_irep , nregs) - <span class="number">2usize</span>] ; [<span class="string">"Offset of field: mrb_irep::clen"</span>] [:: std :: mem :: offset_of ! (mrb_irep , clen) - <span class="number">4usize</span>] ; [<span class="string">"Offset of field: mrb_irep::flags"</span>] [:: std :: mem :: offset_of ! (mrb_irep , flags) - <span class="number">6usize</span>] ; [<span class="string">"Offset of field: mrb_irep::iseq"</span>] [:: std :: mem :: offset_of ! (mrb_irep , iseq) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_irep::pool"</span>] [:: std :: mem :: offset_of ! (mrb_irep , pool) - <span class="number">16usize</span>] ; [<span class="string">"Offset of field: mrb_irep::syms"</span>] [:: std :: mem :: offset_of ! (mrb_irep , syms) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: mrb_irep::reps"</span>] [:: std :: mem :: offset_of ! (mrb_irep , reps) - <span class="number">32usize</span>] ; [<span class="string">"Offset of field: mrb_irep::lv"</span>] [:: std :: mem :: offset_of ! (mrb_irep , lv) - <span class="number">40usize</span>] ; [<span class="string">"Offset of field: mrb_irep::debug_info"</span>] [:: std :: mem :: offset_of ! (mrb_irep , debug_info) - <span class="number">48usize</span>] ; [<span class="string">"Offset of field: mrb_irep::ilen"</span>] [:: std :: mem :: offset_of ! (mrb_irep , ilen) - <span class="number">56usize</span>] ; [<span class="string">"Offset of field: mrb_irep::plen"</span>] [:: std :: mem :: offset_of ! (mrb_irep , plen) - <span class="number">60usize</span>] ; [<span class="string">"Offset of field: mrb_irep::slen"</span>] [:: std :: mem :: offset_of ! (mrb_irep , slen) - <span class="number">62usize</span>] ; [<span class="string">"Offset of field: mrb_irep::rlen"</span>] [:: std :: mem :: offset_of ! (mrb_irep , rlen) - <span class="number">64usize</span>] ; [<span class="string">"Offset of field: mrb_irep::refcnt"</span>] [:: std :: mem :: offset_of ! (mrb_irep , refcnt) - <span class="number">66usize</span>] ; } ; <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_add_irep (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; * <span class="kw-2">mut </span>mrb_irep ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_irep (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>u8) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_irep_buf (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_void , arg3 : usize) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_irep_cxt (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>u8 , arg3 : * <span class="kw-2">mut </span>mrbc_context) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_irep_buf_cxt (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_void , arg3 : usize , arg4 : * <span class="kw-2">mut </span>mrbc_context) -&gt; mrb_value ; } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_insn_data { <span class="kw">pub </span>insn : u8 , <span class="kw">pub </span>a : u32 , <span class="kw">pub </span>b : u16 , <span class="kw">pub </span>c : u16 , <span class="kw">pub </span>addr : * <span class="kw">const </span>mrb_code , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_insn_data"</span>] [:: std :: mem :: size_of :: &lt; mrb_insn_data &gt; () - <span class="number">24usize</span>] ; [<span class="string">"Alignment of mrb_insn_data"</span>] [:: std :: mem :: align_of :: &lt; mrb_insn_data &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_insn_data::insn"</span>] [:: std :: mem :: offset_of ! (mrb_insn_data , insn) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_insn_data::a"</span>] [:: std :: mem :: offset_of ! (mrb_insn_data , a) - <span class="number">4usize</span>] ; [<span class="string">"Offset of field: mrb_insn_data::b"</span>] [:: std :: mem :: offset_of ! (mrb_insn_data , b) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_insn_data::c"</span>] [:: std :: mem :: offset_of ! (mrb_insn_data , c) - <span class="number">10usize</span>] ; [<span class="string">"Offset of field: mrb_insn_data::addr"</span>] [:: std :: mem :: offset_of ! (mrb_insn_data , addr) - <span class="number">16usize</span>] ; } ; <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_irep_incref (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>mrb_irep) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_irep_decref (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>mrb_irep) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_irep_cutref (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>mrb_irep) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_read_irep (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>u8) -&gt; * <span class="kw-2">mut </span>mrb_irep ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_read_irep_buf (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>:: std :: os :: raw :: c_void , arg3 : usize) -&gt; * <span class="kw-2">mut </span>mrb_irep ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_fail (mrb : * <span class="kw-2">mut </span>mrb_state , mesg : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_exc_new_str (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , str_ : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_make_exception (mrb : * <span class="kw-2">mut </span>mrb_state , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_no_method_error (mrb : * <span class="kw-2">mut </span>mrb_state , id : mrb_sym , args : mrb_value , fmt : * <span class="kw">const </span>:: std :: os :: raw :: c_char , ...) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_f_raise (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value) -&gt; mrb_value ; } <span class="kw">pub type </span>mrb_protect_error_func = :: std :: option :: <span class="prelude-ty">Option</span> &lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(mrb : * <span class="kw-2">mut </span>mrb_state , userdata : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; mrb_value &gt; ; <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_protect_error (mrb : * <span class="kw-2">mut </span>mrb_state , body : mrb_protect_error_func , userdata : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , error : * <span class="kw-2">mut </span>mrb_bool) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_protect (mrb : * <span class="kw-2">mut </span>mrb_state , body : mrb_func_t , data : mrb_value , state : * <span class="kw-2">mut </span>mrb_bool) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ensure (mrb : * <span class="kw-2">mut </span>mrb_state , body : mrb_func_t , b_data : mrb_value , ensure : mrb_func_t , e_data : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_rescue (mrb : * <span class="kw-2">mut </span>mrb_state , body : mrb_func_t , b_data : mrb_value , rescue : mrb_func_t , r_data : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_rescue_exceptions (mrb : * <span class="kw-2">mut </span>mrb_state , body : mrb_func_t , b_data : mrb_value , rescue : mrb_func_t , r_data : mrb_value , len : mrb_int , classes : * <span class="kw-2">mut </span>* <span class="kw-2">mut </span>RClass) -&gt; mrb_value ; } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>RHash { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>size : u32 , <span class="kw">pub </span>iv : * <span class="kw-2">mut </span>iv_tbl , <span class="kw">pub </span>ea_capa : u32 , <span class="kw">pub </span>ea_n_used : u32 , <span class="kw">pub </span>hsh : RHash__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>RHash__bindgen_ty_1 { <span class="kw">pub </span>ea : * <span class="kw-2">mut </span>hash_entry , <span class="kw">pub </span>ht : * <span class="kw-2">mut </span>hash_table , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RHash__bindgen_ty_1"</span>] [:: std :: mem :: size_of :: &lt; RHash__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Alignment of RHash__bindgen_ty_1"</span>] [:: std :: mem :: align_of :: &lt; RHash__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RHash__bindgen_ty_1::ea"</span>] [:: std :: mem :: offset_of ! (RHash__bindgen_ty_1 , ea) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RHash__bindgen_ty_1::ht"</span>] [:: std :: mem :: offset_of ! (RHash__bindgen_ty_1 , ht) - <span class="number">0usize</span>] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RHash"</span>] [:: std :: mem :: size_of :: &lt; RHash &gt; () - <span class="number">48usize</span>] ; [<span class="string">"Alignment of RHash"</span>] [:: std :: mem :: align_of :: &lt; RHash &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RHash::c"</span>] [:: std :: mem :: offset_of ! (RHash , c) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RHash::gcnext"</span>] [:: std :: mem :: offset_of ! (RHash , gcnext) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RHash::size"</span>] [:: std :: mem :: offset_of ! (RHash , size) - <span class="number">20usize</span>] ; [<span class="string">"Offset of field: RHash::iv"</span>] [:: std :: mem :: offset_of ! (RHash , iv) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: RHash::ea_capa"</span>] [:: std :: mem :: offset_of ! (RHash , ea_capa) - <span class="number">32usize</span>] ; [<span class="string">"Offset of field: RHash::ea_n_used"</span>] [:: std :: mem :: offset_of ! (RHash , ea_n_used) - <span class="number">36usize</span>] ; [<span class="string">"Offset of field: RHash::hsh"</span>] [:: std :: mem :: offset_of ! (RHash , hsh) - <span class="number">40usize</span>] ; } ; <span class="kw">impl </span>RHash { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>tt_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_tt_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>color_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_color_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>flags_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_flags_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_new_capa (mrb : * <span class="kw-2">mut </span>mrb_state , capa : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_new (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_set (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value , key : mrb_value , val : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_get (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value , key : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_fetch (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value , key : mrb_value , def : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_delete_key (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value , key : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_keys (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_key_p (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value , key : mrb_value) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_empty_p (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_values (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_clear (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_size (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value) -&gt; mrb_int ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_dup (mrb : * <span class="kw-2">mut </span>mrb_state , hash : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_merge (mrb : * <span class="kw-2">mut </span>mrb_state , hash1 : mrb_value , hash2 : mrb_value) ; } <span class="kw">pub type </span>mrb_hash_foreach_func = :: std :: option :: <span class="prelude-ty">Option</span> &lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(mrb : * <span class="kw-2">mut </span>mrb_state , key : mrb_value , val : mrb_value , data : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; :: std :: os :: raw :: c_int &gt; ; <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_hash_foreach (mrb : * <span class="kw-2">mut </span>mrb_state , hash : * <span class="kw-2">mut </span>RHash , func : mrb_hash_foreach_func , p : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_num_add (mrb : * <span class="kw-2">mut </span>mrb_state , x : mrb_value , y : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_num_sub (mrb : * <span class="kw-2">mut </span>mrb_state , x : mrb_value , y : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_num_mul (mrb : * <span class="kw-2">mut </span>mrb_state , x : mrb_value , y : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_integer_to_str (mrb : * <span class="kw-2">mut </span>mrb_state , x : mrb_value , base : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_int_to_cstr (buf : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , len : usize , n : mrb_int , base : mrb_int) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_float_to_integer (mrb : * <span class="kw-2">mut </span>mrb_state , val : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_div_float (x : mrb_float , y : mrb_float) -&gt; mrb_float ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_float_to_str (mrb : * <span class="kw-2">mut </span>mrb_state , x : mrb_value , fmt : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_format_float (f : mrb_float , buf : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , buf_size : usize , fmt : :: std :: os :: raw :: c_char , prec : :: std :: os :: raw :: c_int , sign : :: std :: os :: raw :: c_char) -&gt; :: std :: os :: raw :: c_int ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_insn { OP_NOP = <span class="number">0 </span>, OP_MOVE = <span class="number">1 </span>, OP_LOADL = <span class="number">2 </span>, OP_LOADI = <span class="number">3 </span>, OP_LOADINEG = <span class="number">4 </span>, OP_LOADI__1 = <span class="number">5 </span>, OP_LOADI_0 = <span class="number">6 </span>, OP_LOADI_1 = <span class="number">7 </span>, OP_LOADI_2 = <span class="number">8 </span>, OP_LOADI_3 = <span class="number">9 </span>, OP_LOADI_4 = <span class="number">10 </span>, OP_LOADI_5 = <span class="number">11 </span>, OP_LOADI_6 = <span class="number">12 </span>, OP_LOADI_7 = <span class="number">13 </span>, OP_LOADI16 = <span class="number">14 </span>, OP_LOADI32 = <span class="number">15 </span>, OP_LOADSYM = <span class="number">16 </span>, OP_LOADNIL = <span class="number">17 </span>, OP_LOADSELF = <span class="number">18 </span>, OP_LOADT = <span class="number">19 </span>, OP_LOADF = <span class="number">20 </span>, OP_GETGV = <span class="number">21 </span>, OP_SETGV = <span class="number">22 </span>, OP_GETSV = <span class="number">23 </span>, OP_SETSV = <span class="number">24 </span>, OP_GETIV = <span class="number">25 </span>, OP_SETIV = <span class="number">26 </span>, OP_GETCV = <span class="number">27 </span>, OP_SETCV = <span class="number">28 </span>, OP_GETCONST = <span class="number">29 </span>, OP_SETCONST = <span class="number">30 </span>, OP_GETMCNST = <span class="number">31 </span>, OP_SETMCNST = <span class="number">32 </span>, OP_GETUPVAR = <span class="number">33 </span>, OP_SETUPVAR = <span class="number">34 </span>, OP_GETIDX = <span class="number">35 </span>, OP_SETIDX = <span class="number">36 </span>, OP_JMP = <span class="number">37 </span>, OP_JMPIF = <span class="number">38 </span>, OP_JMPNOT = <span class="number">39 </span>, OP_JMPNIL = <span class="number">40 </span>, OP_JMPUW = <span class="number">41 </span>, OP_EXCEPT = <span class="number">42 </span>, OP_RESCUE = <span class="number">43 </span>, OP_RAISEIF = <span class="number">44 </span>, OP_SSEND = <span class="number">45 </span>, OP_SSENDB = <span class="number">46 </span>, OP_SEND = <span class="number">47 </span>, OP_SENDB = <span class="number">48 </span>, OP_CALL = <span class="number">49 </span>, OP_SUPER = <span class="number">50 </span>, OP_ARGARY = <span class="number">51 </span>, OP_ENTER = <span class="number">52 </span>, OP_KEY_P = <span class="number">53 </span>, OP_KEYEND = <span class="number">54 </span>, OP_KARG = <span class="number">55 </span>, OP_RETURN = <span class="number">56 </span>, OP_RETURN_BLK = <span class="number">57 </span>, OP_BREAK = <span class="number">58 </span>, OP_BLKPUSH = <span class="number">59 </span>, OP_ADD = <span class="number">60 </span>, OP_ADDI = <span class="number">61 </span>, OP_SUB = <span class="number">62 </span>, OP_SUBI = <span class="number">63 </span>, OP_MUL = <span class="number">64 </span>, OP_DIV = <span class="number">65 </span>, OP_EQ = <span class="number">66 </span>, OP_LT = <span class="number">67 </span>, OP_LE = <span class="number">68 </span>, OP_GT = <span class="number">69 </span>, OP_GE = <span class="number">70 </span>, OP_ARRAY = <span class="number">71 </span>, OP_ARRAY2 = <span class="number">72 </span>, OP_ARYCAT = <span class="number">73 </span>, OP_ARYPUSH = <span class="number">74 </span>, OP_ARYSPLAT = <span class="number">75 </span>, OP_AREF = <span class="number">76 </span>, OP_ASET = <span class="number">77 </span>, OP_APOST = <span class="number">78 </span>, OP_INTERN = <span class="number">79 </span>, OP_SYMBOL = <span class="number">80 </span>, OP_STRING = <span class="number">81 </span>, OP_STRCAT = <span class="number">82 </span>, OP_HASH = <span class="number">83 </span>, OP_HASHADD = <span class="number">84 </span>, OP_HASHCAT = <span class="number">85 </span>, OP_LAMBDA = <span class="number">86 </span>, OP_BLOCK = <span class="number">87 </span>, OP_METHOD = <span class="number">88 </span>, OP_RANGE_INC = <span class="number">89 </span>, OP_RANGE_EXC = <span class="number">90 </span>, OP_OCLASS = <span class="number">91 </span>, OP_CLASS = <span class="number">92 </span>, OP_MODULE = <span class="number">93 </span>, OP_EXEC = <span class="number">94 </span>, OP_DEF = <span class="number">95 </span>, OP_ALIAS = <span class="number">96 </span>, OP_UNDEF = <span class="number">97 </span>, OP_SCLASS = <span class="number">98 </span>, OP_TCLASS = <span class="number">99 </span>, OP_DEBUG = <span class="number">100 </span>, OP_ERR = <span class="number">101 </span>, OP_EXT1 = <span class="number">102 </span>, OP_EXT2 = <span class="number">103 </span>, OP_EXT3 = <span class="number">104 </span>, OP_STOP = <span class="number">105 </span>, } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>REnv { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>stack : * <span class="kw-2">mut </span>mrb_value , <span class="kw">pub </span>cxt : * <span class="kw-2">mut </span>mrb_context , <span class="kw">pub </span>mid : mrb_sym , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of REnv"</span>] [:: std :: mem :: size_of :: &lt; REnv &gt; () - <span class="number">48usize</span>] ; [<span class="string">"Alignment of REnv"</span>] [:: std :: mem :: align_of :: &lt; REnv &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: REnv::c"</span>] [:: std :: mem :: offset_of ! (REnv , c) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: REnv::gcnext"</span>] [:: std :: mem :: offset_of ! (REnv , gcnext) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: REnv::stack"</span>] [:: std :: mem :: offset_of ! (REnv , stack) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: REnv::cxt"</span>] [:: std :: mem :: offset_of ! (REnv , cxt) - <span class="number">32usize</span>] ; [<span class="string">"Offset of field: REnv::mid"</span>] [:: std :: mem :: offset_of ! (REnv , mid) - <span class="number">40usize</span>] ; } ; <span class="kw">impl </span>REnv { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>tt_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_tt_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>color_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_color_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>flags_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_flags_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_env_unshare (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw-2">mut </span>REnv , noraise : mrb_bool) -&gt; mrb_bool ; } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>RProc { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>body : RProc__bindgen_ty_1 , <span class="kw">pub </span>upper : * <span class="kw">const </span>RProc , <span class="kw">pub </span>e : RProc__bindgen_ty_2 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>RProc__bindgen_ty_1 { <span class="kw">pub </span>irep : * <span class="kw">const </span>mrb_irep , <span class="kw">pub </span>func : mrb_func_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RProc__bindgen_ty_1"</span>] [:: std :: mem :: size_of :: &lt; RProc__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Alignment of RProc__bindgen_ty_1"</span>] [:: std :: mem :: align_of :: &lt; RProc__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RProc__bindgen_ty_1::irep"</span>] [:: std :: mem :: offset_of ! (RProc__bindgen_ty_1 , irep) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RProc__bindgen_ty_1::func"</span>] [:: std :: mem :: offset_of ! (RProc__bindgen_ty_1 , func) - <span class="number">0usize</span>] ; } ; # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>RProc__bindgen_ty_2 { <span class="kw">pub </span>target_class : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>env : * <span class="kw-2">mut </span>REnv , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RProc__bindgen_ty_2"</span>] [:: std :: mem :: size_of :: &lt; RProc__bindgen_ty_2 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Alignment of RProc__bindgen_ty_2"</span>] [:: std :: mem :: align_of :: &lt; RProc__bindgen_ty_2 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RProc__bindgen_ty_2::target_class"</span>] [:: std :: mem :: offset_of ! (RProc__bindgen_ty_2 , target_class) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RProc__bindgen_ty_2::env"</span>] [:: std :: mem :: offset_of ! (RProc__bindgen_ty_2 , env) - <span class="number">0usize</span>] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RProc"</span>] [:: std :: mem :: size_of :: &lt; RProc &gt; () - <span class="number">48usize</span>] ; [<span class="string">"Alignment of RProc"</span>] [:: std :: mem :: align_of :: &lt; RProc &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RProc::c"</span>] [:: std :: mem :: offset_of ! (RProc , c) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RProc::gcnext"</span>] [:: std :: mem :: offset_of ! (RProc , gcnext) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RProc::body"</span>] [:: std :: mem :: offset_of ! (RProc , body) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: RProc::upper"</span>] [:: std :: mem :: offset_of ! (RProc , upper) - <span class="number">32usize</span>] ; [<span class="string">"Offset of field: RProc::e"</span>] [:: std :: mem :: offset_of ! (RProc , e) - <span class="number">40usize</span>] ; } ; <span class="kw">impl </span>RProc { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>tt_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_tt_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>color_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_color_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>flags_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_flags_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_proc_new (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : * <span class="kw">const </span>mrb_irep) -&gt; * <span class="kw-2">mut </span>RProc ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_proc_new_cfunc (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_func_t) -&gt; * <span class="kw-2">mut </span>RProc ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_closure_new_cfunc (mrb : * <span class="kw-2">mut </span>mrb_state , func : mrb_func_t , nlocals : :: std :: os :: raw :: c_int) -&gt; * <span class="kw-2">mut </span>RProc ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_proc_new_cfunc_with_env (mrb : * <span class="kw-2">mut </span>mrb_state , func : mrb_func_t , argc : mrb_int , argv : * <span class="kw">const </span>mrb_value) -&gt; * <span class="kw-2">mut </span>RProc ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_proc_cfunc_env_get (mrb : * <span class="kw-2">mut </span>mrb_state , idx : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_load_proc (mrb : * <span class="kw-2">mut </span>mrb_state , proc_ : * <span class="kw">const </span>RProc) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vm_ci_proc_set (ci : * <span class="kw-2">mut </span>mrb_callinfo , p : * <span class="kw">const </span>RProc) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vm_ci_target_class (ci : * <span class="kw">const </span>mrb_callinfo) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vm_ci_target_class_set (ci : * <span class="kw-2">mut </span>mrb_callinfo , tc : * <span class="kw-2">mut </span>RClass) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vm_ci_env (ci : * <span class="kw">const </span>mrb_callinfo) -&gt; * <span class="kw-2">mut </span>REnv ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_vm_ci_env_set (ci : * <span class="kw-2">mut </span>mrb_callinfo , e : * <span class="kw-2">mut </span>REnv) ; } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>mrb_range_edges { <span class="kw">pub </span>beg : mrb_value , <span class="kw">pub </span>end : mrb_value , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_range_edges"</span>] [:: std :: mem :: size_of :: &lt; mrb_range_edges &gt; () - <span class="number">32usize</span>] ; [<span class="string">"Alignment of mrb_range_edges"</span>] [:: std :: mem :: align_of :: &lt; mrb_range_edges &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_range_edges::beg"</span>] [:: std :: mem :: offset_of ! (mrb_range_edges , beg) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: mrb_range_edges::end"</span>] [:: std :: mem :: offset_of ! (mrb_range_edges , end) - <span class="number">16usize</span>] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>RRange { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>edges : * <span class="kw-2">mut </span>mrb_range_edges , <span class="kw">pub </span>excl : mrb_bool , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RRange"</span>] [:: std :: mem :: size_of :: &lt; RRange &gt; () - <span class="number">40usize</span>] ; [<span class="string">"Alignment of RRange"</span>] [:: std :: mem :: align_of :: &lt; RRange &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RRange::c"</span>] [:: std :: mem :: offset_of ! (RRange , c) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RRange::gcnext"</span>] [:: std :: mem :: offset_of ! (RRange , gcnext) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RRange::edges"</span>] [:: std :: mem :: offset_of ! (RRange , edges) - <span class="number">24usize</span>] ; [<span class="string">"Offset of field: RRange::excl"</span>] [:: std :: mem :: offset_of ! (RRange , excl) - <span class="number">32usize</span>] ; } ; <span class="kw">impl </span>RRange { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>tt_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_tt_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>color_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_color_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>flags_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_flags_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_range_ptr (mrb : * <span class="kw-2">mut </span>mrb_state , range : mrb_value) -&gt; * <span class="kw-2">mut </span>RRange ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_range_new (mrb : * <span class="kw-2">mut </span>mrb_state , start : mrb_value , end : mrb_value , exclude : mrb_bool) -&gt; mrb_value ; } # [repr (u32)] # [derive (Debug , Copy , Clone , Hash , PartialEq , Eq)] <span class="kw">pub enum </span>mrb_range_beg_len { MRB_RANGE_TYPE_MISMATCH = <span class="number">0 </span>, MRB_RANGE_OK = <span class="number">1 </span>, MRB_RANGE_OUT = <span class="number">2 </span>, } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_range_beg_len (mrb : * <span class="kw-2">mut </span>mrb_state , range : mrb_value , begp : * <span class="kw-2">mut </span>mrb_int , lenp : * <span class="kw-2">mut </span>mrb_int , len : mrb_int , trunc : mrb_bool) -&gt; mrb_range_beg_len ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub static </span>mrb_digitmap : [:: std :: os :: raw :: c_char ; <span class="number">0usize</span>] ; } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>RString { <span class="kw">pub </span>c : * <span class="kw-2">mut </span>RClass , <span class="kw">pub </span>gcnext : * <span class="kw-2">mut </span>RBasic , <span class="kw">pub </span>_bitfield_align_1 : [u32 ; <span class="number">0</span>] , <span class="kw">pub </span>_bitfield_1 : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; , <span class="kw">pub </span>as_ : RString__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>RString__bindgen_ty_1 { <span class="kw">pub </span>heap : RString__bindgen_ty_1__bindgen_ty_1 , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub struct </span>RString__bindgen_ty_1__bindgen_ty_1 { <span class="kw">pub </span>len : mrb_ssize , <span class="kw">pub </span>aux : RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , <span class="kw">pub </span>ptr : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , } # [repr (C)] # [derive (Copy , Clone)] <span class="kw">pub union </span>RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 { <span class="kw">pub </span>capa : mrb_ssize , <span class="kw">pub </span>shared : * <span class="kw-2">mut </span>mrb_shared_string , <span class="kw">pub </span>fshared : * <span class="kw-2">mut </span>RString , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"</span>] [:: std :: mem :: size_of :: &lt; RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Alignment of RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"</span>] [:: std :: mem :: align_of :: &lt; RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::capa"</span>] [:: std :: mem :: offset_of ! (RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , capa) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::shared"</span>] [:: std :: mem :: offset_of ! (RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , shared) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1::fshared"</span>] [:: std :: mem :: offset_of ! (RString__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1 , fshared) - <span class="number">0usize</span>] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RString__bindgen_ty_1__bindgen_ty_1"</span>] [:: std :: mem :: size_of :: &lt; RString__bindgen_ty_1__bindgen_ty_1 &gt; () - <span class="number">24usize</span>] ; [<span class="string">"Alignment of RString__bindgen_ty_1__bindgen_ty_1"</span>] [:: std :: mem :: align_of :: &lt; RString__bindgen_ty_1__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RString__bindgen_ty_1__bindgen_ty_1::len"</span>] [:: std :: mem :: offset_of ! (RString__bindgen_ty_1__bindgen_ty_1 , len) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RString__bindgen_ty_1__bindgen_ty_1::aux"</span>] [:: std :: mem :: offset_of ! (RString__bindgen_ty_1__bindgen_ty_1 , aux) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RString__bindgen_ty_1__bindgen_ty_1::ptr"</span>] [:: std :: mem :: offset_of ! (RString__bindgen_ty_1__bindgen_ty_1 , ptr) - <span class="number">16usize</span>] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RString__bindgen_ty_1"</span>] [:: std :: mem :: size_of :: &lt; RString__bindgen_ty_1 &gt; () - <span class="number">24usize</span>] ; [<span class="string">"Alignment of RString__bindgen_ty_1"</span>] [:: std :: mem :: align_of :: &lt; RString__bindgen_ty_1 &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RString__bindgen_ty_1::heap"</span>] [:: std :: mem :: offset_of ! (RString__bindgen_ty_1 , heap) - <span class="number">0usize</span>] ; } ; # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of RString"</span>] [:: std :: mem :: size_of :: &lt; RString &gt; () - <span class="number">48usize</span>] ; [<span class="string">"Alignment of RString"</span>] [:: std :: mem :: align_of :: &lt; RString &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RString::c"</span>] [:: std :: mem :: offset_of ! (RString , c) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: RString::gcnext"</span>] [:: std :: mem :: offset_of ! (RString , gcnext) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: RString::as_"</span>] [:: std :: mem :: offset_of ! (RString , as_) - <span class="number">24usize</span>] ; } ; <span class="kw">impl </span>RString { # [inline] <span class="kw">pub fn </span>tt (&amp; <span class="self">self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">0usize </span>, <span class="number">8u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_tt (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>tt_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; mrb_vtype { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_tt_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : mrb_vtype) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">0usize </span>, <span class="number">8u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>color (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">8usize </span>, <span class="number">3u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_color (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>color_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_color_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">8usize </span>, <span class="number">3u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>flags (&amp; <span class="self">self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (<span class="self">self </span>. _bitfield_1 . get (<span class="number">11usize </span>, <span class="number">21u8</span>) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub fn </span>set_flags (&amp; <span class="kw-2">mut </span><span class="self">self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; <span class="self">self </span>. _bitfield_1 . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64) } } # [inline] <span class="kw">pub unsafe fn </span>flags_raw (this : * <span class="kw">const </span><span class="self">Self</span>) -&gt; u32 { <span class="kw">unsafe </span>{ :: std :: mem :: transmute (&lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_get (:: std :: ptr :: addr_of ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>,) <span class="kw">as </span>u32) } } # [inline] <span class="kw">pub unsafe fn </span>set_flags_raw (this : * <span class="kw-2">mut </span><span class="self">Self </span>, val : u32) { <span class="kw">unsafe </span>{ <span class="kw">let </span>val : u32 = :: std :: mem :: transmute (val) ; &lt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; &gt; :: raw_set (:: std :: ptr :: addr_of_mut ! ((* this) . _bitfield_1) , <span class="number">11usize </span>, <span class="number">21u8 </span>, val <span class="kw">as </span>u64 ,) } } # [inline] <span class="kw">pub fn </span>new_bitfield_1 (tt : mrb_vtype , color : u32 , flags : u32) -&gt; __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; { <span class="kw">let </span><span class="kw-2">mut </span>__bindgen_bitfield_unit : __BindgenBitfieldUnit &lt; [u8 ; <span class="number">4usize</span>] &gt; = Default :: default () ; __bindgen_bitfield_unit . set (<span class="number">0usize </span>, <span class="number">8u8 </span>, { <span class="kw">let </span>tt : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (tt) } ; tt <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">8usize </span>, <span class="number">3u8 </span>, { <span class="kw">let </span>color : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (color) } ; color <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit . set (<span class="number">11usize </span>, <span class="number">21u8 </span>, { <span class="kw">let </span>flags : u32 = <span class="kw">unsafe </span>{ :: std :: mem :: transmute (flags) } ; flags <span class="kw">as </span>u64 }) ; __bindgen_bitfield_unit } } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_modify (mrb : * <span class="kw-2">mut </span>mrb_state , s : * <span class="kw-2">mut </span>RString) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_modify_keep_ascii (mrb : * <span class="kw-2">mut </span>mrb_state , s : * <span class="kw-2">mut </span>RString) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_index (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , p : * <span class="kw">const </span>:: std :: os :: raw :: c_char , len : mrb_int , offset : mrb_int) -&gt; mrb_int ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_concat (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value , other : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_plus (mrb : * <span class="kw-2">mut </span>mrb_state , a : mrb_value , b : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_ptr_to_str (mrb : * <span class="kw-2">mut </span>mrb_state , p : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_as_string (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_resize (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , len : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_substr (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , beg : mrb_int , len : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_new_capa (mrb : * <span class="kw-2">mut </span>mrb_state , capa : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_string_cstr (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_string_value_cstr (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : * <span class="kw-2">mut </span>mrb_value) -&gt; * <span class="kw">const </span>:: std :: os :: raw :: c_char ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_dup (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_intern (mrb : * <span class="kw-2">mut </span>mrb_state , self_ : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_to_integer (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , base : mrb_int , badcheck : mrb_bool) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_to_dbl (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , badcheck : mrb_bool) -&gt; f64 ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_equal (mrb : * <span class="kw-2">mut </span>mrb_state , str1 : mrb_value , str2 : mrb_value) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_cat (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , ptr : * <span class="kw">const </span>:: std :: os :: raw :: c_char , len : usize) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_cat_cstr (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , ptr : * <span class="kw">const </span>:: std :: os :: raw :: c_char) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_cat_str (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , str2 : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_append (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value , str2 : mrb_value) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_cmp (mrb : * <span class="kw-2">mut </span>mrb_state , str1 : mrb_value , str2 : mrb_value) -&gt; :: std :: os :: raw :: c_int ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_str_to_cstr (mrb : * <span class="kw-2">mut </span>mrb_state , str_ : mrb_value) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char ; } <span class="kw">pub type </span>__jmp_buf = [:: std :: os :: raw :: c_long ; <span class="number">8usize</span>] ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>__jmp_buf_tag { <span class="kw">pub </span>__jmpbuf : __jmp_buf , <span class="kw">pub </span>__mask_was_saved : :: std :: os :: raw :: c_int , <span class="kw">pub </span>__saved_mask : __sigset_t , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of __jmp_buf_tag"</span>] [:: std :: mem :: size_of :: &lt; __jmp_buf_tag &gt; () - <span class="number">200usize</span>] ; [<span class="string">"Alignment of __jmp_buf_tag"</span>] [:: std :: mem :: align_of :: &lt; __jmp_buf_tag &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: __jmp_buf_tag::__jmpbuf"</span>] [:: std :: mem :: offset_of ! (__jmp_buf_tag , __jmpbuf) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: __jmp_buf_tag::__mask_was_saved"</span>] [:: std :: mem :: offset_of ! (__jmp_buf_tag , __mask_was_saved) - <span class="number">64usize</span>] ; [<span class="string">"Offset of field: __jmp_buf_tag::__saved_mask"</span>] [:: std :: mem :: offset_of ! (__jmp_buf_tag , __saved_mask) - <span class="number">72usize</span>] ; } ; <span class="kw">pub type </span>jmp_buf = [__jmp_buf_tag ; <span class="number">1usize</span>] ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_jmpbuf { <span class="kw">pub </span>impl_ : jmp_buf , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of mrb_jmpbuf"</span>] [:: std :: mem :: size_of :: &lt; mrb_jmpbuf &gt; () - <span class="number">200usize</span>] ; [<span class="string">"Alignment of mrb_jmpbuf"</span>] [:: std :: mem :: align_of :: &lt; mrb_jmpbuf &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: mrb_jmpbuf::impl_"</span>] [:: std :: mem :: offset_of ! (mrb_jmpbuf , impl_) - <span class="number">0usize</span>] ; } ; <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_const_get (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value , arg3 : mrb_sym) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_const_set (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value , arg3 : mrb_sym , arg4 : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_const_defined (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value , arg3 : mrb_sym) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_const_remove (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value , arg3 : mrb_sym) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_name_sym_p (mrb : * <span class="kw-2">mut </span>mrb_state , sym : mrb_sym) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_name_sym_check (mrb : * <span class="kw-2">mut </span>mrb_state , sym : mrb_sym) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_iv_get (mrb : * <span class="kw-2">mut </span>mrb_state , obj : * <span class="kw-2">mut </span>RObject , sym : mrb_sym) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_iv_set (mrb : * <span class="kw-2">mut </span>mrb_state , obj : * <span class="kw-2">mut </span>RObject , sym : mrb_sym , v : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_obj_iv_defined (mrb : * <span class="kw-2">mut </span>mrb_state , obj : * <span class="kw-2">mut </span>RObject , sym : mrb_sym) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_get (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , sym : mrb_sym) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_set (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , sym : mrb_sym , v : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_defined (arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_value , arg3 : mrb_sym) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_remove (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , sym : mrb_sym) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_copy (mrb : * <span class="kw-2">mut </span>mrb_state , dst : mrb_value , src : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_const_defined_at (mrb : * <span class="kw-2">mut </span>mrb_state , mod_ : mrb_value , id : mrb_sym) -&gt; mrb_bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_gv_get (mrb : * <span class="kw-2">mut </span>mrb_state , sym : mrb_sym) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_gv_set (mrb : * <span class="kw-2">mut </span>mrb_state , sym : mrb_sym , val : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_gv_remove (mrb : * <span class="kw-2">mut </span>mrb_state , sym : mrb_sym) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_cv_get (mrb : * <span class="kw-2">mut </span>mrb_state , mod_ : mrb_value , sym : mrb_sym) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_mod_cv_set (mrb : * <span class="kw-2">mut </span>mrb_state , c : * <span class="kw-2">mut </span>RClass , sym : mrb_sym , v : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_cv_set (mrb : * <span class="kw-2">mut </span>mrb_state , mod_ : mrb_value , sym : mrb_sym , v : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_cv_defined (mrb : * <span class="kw-2">mut </span>mrb_state , mod_ : mrb_value , sym : mrb_sym) -&gt; mrb_bool ; } <span class="kw">pub type </span>mrb_iv_foreach_func = :: std :: option :: <span class="prelude-ty">Option</span> &lt; <span class="kw">unsafe extern </span><span class="string">"C" </span><span class="kw">fn </span>(arg1 : * <span class="kw-2">mut </span>mrb_state , arg2 : mrb_sym , arg3 : mrb_value , arg4 : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; :: std :: os :: raw :: c_int &gt; ; <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_iv_foreach (mrb : * <span class="kw-2">mut </span>mrb_state , obj : mrb_value , func : mrb_iv_foreach_func , p : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_value_has_method (mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_value , method : mrb_sym) -&gt; bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_value_is_nil (value : mrb_value) -&gt; bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_value_is_false (value : mrb_value) -&gt; bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_value_is_true (value : mrb_value) -&gt; bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_range_excl (mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_value) -&gt; bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_obj_frozen (mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_value) -&gt; bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_fixnum_to_cint (value : mrb_value) -&gt; mrb_int ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_float_to_cdouble (value : mrb_value) -&gt; mrb_float ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_cptr_ptr (value : mrb_value) -&gt; * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_basic_ptr (value : mrb_value) -&gt; * <span class="kw-2">mut </span>RBasic ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_obj_ptr (value : mrb_value) -&gt; * <span class="kw-2">mut </span>RObject ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_proc_ptr (value : mrb_value) -&gt; * <span class="kw-2">mut </span>RProc ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_class_ptr (value : mrb_value) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_class_to_rclass (value : mrb_value) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_class_of_value (mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_value) -&gt; * <span class="kw-2">mut </span>RClass ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_nil_value () -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_false_value () -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_true_value () -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_fixnum_value (value : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_float_value (mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_float) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_cptr_value (mrb : * <span class="kw-2">mut </span>mrb_state , ptr : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_obj_value (p : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_class_value (klass : * <span class="kw-2">mut </span>RClass) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_module_value (module : * <span class="kw-2">mut </span>RClass) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_data_value (data : * <span class="kw-2">mut </span>RData) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_proc_value (mrb : * <span class="kw-2">mut </span>mrb_state , proc_ : * <span class="kw-2">mut </span>RProc) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_new_symbol (id : mrb_sym) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_set_instance_tt (klass : * <span class="kw-2">mut </span>RClass , type_ : mrb_vtype) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_data_init (value : * <span class="kw-2">mut </span>mrb_value , ptr : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , type_ : * <span class="kw">const </span>mrb_data_type) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_raise (mrb : * <span class="kw-2">mut </span>mrb_state , eklass : * <span class="kw">const </span>:: std :: os :: raw :: c_char , msg : * <span class="kw">const </span>:: std :: os :: raw :: c_char) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_raise_current_exception (mrb : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_alloc_rarray (mrb : * <span class="kw-2">mut </span>mrb_state , ptr : * <span class="kw-2">mut </span>mrb_value , len : mrb_int , capa : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_repack_into_rarray (ptr : * <span class="kw-2">mut </span>mrb_value , len : mrb_int , capa : mrb_int , into : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_alloc_rstring (mrb : * <span class="kw-2">mut </span>mrb_state , ptr : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , len : mrb_int , capa : mrb_int) -&gt; mrb_value ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_repack_into_rstring (ptr : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_char , len : mrb_int , capa : mrb_int , into : mrb_value) -&gt; * <span class="kw-2">mut </span>RString ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_gc_arena_save (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; :: std :: os :: raw :: c_int ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_gc_arena_restore (mrb : * <span class="kw-2">mut </span>mrb_state , arena_index : :: std :: os :: raw :: c_int) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_gc_disable (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_gc_enable (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_value_is_dead (_mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_value) -&gt; bool ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_gc_live_objects (mrb : * <span class="kw-2">mut </span>mrb_state) -&gt; usize ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_sys_safe_gc_mark (mrb : * <span class="kw-2">mut </span>mrb_state , value : mrb_value) ; } <span class="kw">unsafe extern </span><span class="string">"C" </span>{ <span class="kw">pub fn </span>mrb_init_mrbgems (mrb : * <span class="kw-2">mut </span>mrb_state) ; } <span class="kw">pub type </span>__builtin_va_list = [__va_list_tag ; <span class="number">1usize</span>] ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>__va_list_tag { <span class="kw">pub </span>gp_offset : :: std :: os :: raw :: c_uint , <span class="kw">pub </span>fp_offset : :: std :: os :: raw :: c_uint , <span class="kw">pub </span>overflow_arg_area : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , <span class="kw">pub </span>reg_save_area : * <span class="kw-2">mut </span>:: std :: os :: raw :: c_void , } # [allow (clippy :: unnecessary_operation , clippy :: identity_op)] <span class="kw">const _ </span>: () = { [<span class="string">"Size of __va_list_tag"</span>] [:: std :: mem :: size_of :: &lt; __va_list_tag &gt; () - <span class="number">24usize</span>] ; [<span class="string">"Alignment of __va_list_tag"</span>] [:: std :: mem :: align_of :: &lt; __va_list_tag &gt; () - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: __va_list_tag::gp_offset"</span>] [:: std :: mem :: offset_of ! (__va_list_tag , gp_offset) - <span class="number">0usize</span>] ; [<span class="string">"Offset of field: __va_list_tag::fp_offset"</span>] [:: std :: mem :: offset_of ! (__va_list_tag , fp_offset) - <span class="number">4usize</span>] ; [<span class="string">"Offset of field: __va_list_tag::overflow_arg_area"</span>] [:: std :: mem :: offset_of ! (__va_list_tag , overflow_arg_area) - <span class="number">8usize</span>] ; [<span class="string">"Offset of field: __va_list_tag::reg_save_area"</span>] [:: std :: mem :: offset_of ! (__va_list_tag , reg_save_area) - <span class="number">16usize</span>] ; } ; # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>iv_tbl { <span class="kw">pub </span>_address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mt_tbl { <span class="kw">pub </span>_address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>parser_lex_strterm { <span class="kw">pub </span>_address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_irep_debug_info { <span class="kw">pub </span>_address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>hash_entry { <span class="kw">pub </span>_address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>hash_table { <span class="kw">pub </span>_address : u8 , } # [repr (C)] # [derive (Debug , Copy , Clone)] <span class="kw">pub struct </span>mrb_shared_string { <span class="kw">pub </span>_address : u8 , }</code></pre></div></section></main></body></html>